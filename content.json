{"meta":{"title":"张君韵","subtitle":"张君韵の博客","description":"本科 | 计算机科学与技术 | 嵌入式","author":"张君韵","url":"https://tqoqt.github.io","root":"/"},"pages":[{"title":"","date":"2021-08-24T17:07:11.998Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://tqoqt.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"404.html","permalink":"https://tqoqt.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2021-08-24T17:07:12.002Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://tqoqt.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/index.html","permalink":"https://tqoqt.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"about/index.html","permalink":"https://tqoqt.github.io/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"archives/index.html","permalink":"https://tqoqt.github.io/archives/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2022-01-23T10:36:35.939Z","comments":true,"path":"contact/index.html","permalink":"https://tqoqt.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 链接 Luckeyの友链信息 博客名称: Luckeyの博客 博客网址: http://www.luckyzmj.cn 博客头像: https://s1.ax1x.com/2020/05/17/YRWsYT.png 博客介绍: The harder you work, the luckier you will be IDM链接信息 软件名称: IDM 软件网址: https://pan.baidu.com/s/1DwP_q5BwKhiin0WVUsMv4Q 软件提取码：1234 博客头像: https://s1.ax1x.com/2020/05/17/YRWsYT.png 软件介绍: 直链下载，快速下载可破解百度网盘下载"},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"census/index.html","permalink":"https://tqoqt.github.io/census/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"categories/index.html","permalink":"https://tqoqt.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"tags/index.html","permalink":"https://tqoqt.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-08-24T17:07:11.890Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/index.html","permalink":"https://tqoqt.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"friends/index.html","permalink":"https://tqoqt.github.io/friends/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"resource/index.html","permalink":"https://tqoqt.github.io/resource/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/movies/index.html","permalink":"https://tqoqt.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/music/index.html","permalink":"https://tqoqt.github.io/List/music/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2021-08-24T17:07:11.891Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://tqoqt.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/tools/index.html","permalink":"https://tqoqt.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2021-08-24T17:07:11.891Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://tqoqt.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2021-08-24T17:07:11.892Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://tqoqt.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2021-08-24T17:07:11.893Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://tqoqt.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2021-08-24T17:07:11.894Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://tqoqt.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2021-08-24T17:07:11.895Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://tqoqt.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2021-08-24T17:07:11.893Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://tqoqt.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2021-08-24T17:07:11.897Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://tqoqt.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2021-08-24T17:07:11.897Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://tqoqt.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2021-08-24T17:07:11.898Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://tqoqt.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2021-08-24T17:07:11.895Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://tqoqt.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2021-08-24T17:07:11.899Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://tqoqt.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-09-07T15:34:34.000Z","updated":"2021-09-07T15:35:06.206Z","comments":true,"path":"tags/index-1.html","permalink":"https://tqoqt.github.io/tags/index-1.html","excerpt":"","text":""},{"title":"个人博客","date":"2021-09-06T15:00:00.000Z","updated":"2021-10-07T16:15:00.544Z","comments":true,"path":"个人介绍.html","permalink":"https://tqoqt.github.io/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D.html","excerpt":"","text":"前言这是记录自己的小生活吧 1、前往深圳日 8月15日：第一次做火车啦，开往深圳的第一步，还对于火车很是好奇的，只记得小时候前往梅州过一次，第一次踏出离开赣州的第一步。 8月16日：到达深圳龙华区在福州那边蹭吃蹭喝，去了在光明区的振源电气一般般太偏了，最后决定不去，还是去了优创亿。 8月17日：去了优创亿报道，正式上班了 8月18日：搬家了，搬到固戍这边了，离地铁超近，但高兴的太早，第二天的排队吓到我了 8月19日：晚上发现带来的698元就快花完了，找老爸要了一波给了500，感觉家里还是很难的。 8月20日：乡下的孩子第一次看海了 8月28日：去了华强北一趟，感受了一波繁华，买了个耳机，感觉被骗了还是没抵住诱惑 老妈打电话过来了问了一下过的咋样，感觉难受 9月03日:被瓜皮气到难受，聊到了高中同学，讲到了邱四狗，结果第二天就突然发消息来了，吓人。 9月05日：儿砸闹分手了，连夜飞抵南昌，啧啧啧，半月工资没了，恋爱太费钱，又是恐爱的一天，找到一张老图。 也不知这个四狗居然这么能保存，应该是当初和化学老师哪里偷拍的，这个不孝女。 9月06日：正式开始记录自己生活啦，搞好了Picgo了，✌ 9月07日记录第一天，看开了，这个班也就那样，要培训就培训呗，就这样，该划水划水，你布置任务就卡着点完成呗。 9月15日 ​ 空了好久没记录了，今天突然杨工突然说给我争取到6.5K了，跑什么路，给钱就是大爷啊。 发现听歌也挺久了，嘻嘻嘻。最近喜欢白山茶啊，不能去想了，女人只会影响敲代码的速度。 9月20日去红树林看海和晚霞了，是真不错啊 9月26日开始玩花的啦，嘻嘻嘻 10月1日回家真的难啊，盒饭25，难吃还巨贵 10月3日","author":"张君韵"},{"title":"相册","date":"2021-09-05T16:00:00.000Z","updated":"2021-10-27T12:17:14.227Z","comments":true,"path":"图库.html","permalink":"https://tqoqt.github.io/%E5%9B%BE%E5%BA%93.html","excerpt":"","text":"2021/10/26回校","author":"张君韵"}],"posts":[{"title":"","slug":"百度网盘快速下载","date":"2022-01-22T16:00:00.000Z","updated":"2022-01-23T10:08:38.662Z","comments":true,"path":"posts/baiduwanpang.html","link":"","permalink":"https://tqoqt.github.io/posts/baiduwanpang.html","excerpt":"","text":"软件准备EDG、IDM、油猴 油猴：Greasy Fork - 安全、实用的用户脚本大全 IDM：链接：https://pan.baidu.com/s/1DwP_q5BwKhiin0WVUsMv4Q 提取码：1234 脚本油猴安装派派助手 使用方法把要下载的保存到自己网盘，把UA复制到IDM选项中的位置，再新建任务，把直链复制开始下载。","categories":[{"name":"技巧篇","slug":"技巧篇","permalink":"https://tqoqt.github.io/categories/%E6%8A%80%E5%B7%A7%E7%AF%87/"}],"tags":[],"author":"张君韵"},{"title":"C语言进阶学习","slug":"2022-01-03-C语言进阶学习","date":"2022-01-03T01:00:00.000Z","updated":"2022-01-04T13:41:00.337Z","comments":true,"path":"posts/c.html","link":"","permalink":"https://tqoqt.github.io/posts/c.html","excerpt":"","text":"1、void 与 void*void表示的是无类型，不可以采用这个类型声明变量或常量，但是可以把指针定义为void类型，如void* ptr。 void指针可以指向任意类型的数据，可用任意数据类型的指针对void指针赋值，比如int *ptrInt；void *ptrVoid = ptrInt ;指针的赋值可以认为是地址的传递，而一般的32位系统指针都是占用4个字节，所以指针赋值仅仅只是这4个字节的赋值与类型没什么关系。 void * memcpy( void *dest, const void *src, size_t len ); void * memset( void * buffer, int c, size_t num); 2、volatile关键字volatile修饰表示变量是易变的，编译器中的优化器在用到这个变量时必须每次都小心地从内存中重新读取这个变量的值，而不是使用保存在寄存器里的备份，有效的防止编译器自动优化，从而与软件设计相符合。 3、数据占用大小数据占用大小是指不同的数据类型在平台中所占用的字节个数，不同的平台不同类型占用的字节个数稍有不同，不过在对应的平台进行开发过程中，必须要对每个数据类型的占用大小了如指掌，否则各种数据溢出，数据越界等等接踵而来。下面是简单罗列的一些数据占用情况:(在一般32位PC中) char 8bit short 16bit int 32bit long 32bit float 32bit double 64bit 4、const与指针const是恒定不变的意思，与指针的结合主要的问题是其const在指针中的位置导致该变量属性不同。主要的识别办法是去掉数据类型，看const修饰的是哪部分。 const int ptr –&gt; const ptr –&gt;那么const修饰的就是ptr，而ptr表示的是指针所指向内容，所以其总体也叫”常量指针”表示值无法改变。 int *const ptr –&gt; *const ptr –&gt;那么const修饰的就是ptr，而ptr表示的是指针变量，指针变量的值就是地址，所以总体也叫”指针常量”表示地址无法改变。 5、结构体与共联体对于结构体和共联体在嵌入式领域是使用得非常频繁的，一些可编程芯片提供的寄存器库都是采用结构体和共联体结合的方式来提供给软件人员进行开发，同时在平时的编码过程中这两个数据类型的灵活应用也能够实现代码更好的封装与简化。 如下面的简单示例，就可以非常灵活的访问Val中的bit位。 typedef union { BYTE Val; struct __packed { BYTE b0:1; BYTE b1:1; BYTE b2:1; BYTE b3:1; BYTE b4:1; BYTE b5:1; BYTE b6:1; BYTE b7:1; } bits; }BYTE_VAL, BYTE_BITS; 6、预定义标识符一般编译器都支持预定义标识符，这些标识符结合printf等打印信息帮助程序员调试程序是非常有用的，一般编译器会自动根据用户指定完成替换和处理。 如下是常用的标识: FILE ：表示进行编译的源文件字符串； LINE ：表示当前文件的行号； __DATE__：表示文件日期； TIME ：表示文件时间； 使用范例: printf(\"file:%s\\n line:%d \\n data:%s \\n time: %s \\n\",__FILE__,__LINE__,__DATE__,__TIME__); 7、#与###：是一种运算符，用于带参宏的文本替换，将跟在后面的参数转成一个字符串常量。 ##：是一种运算符，是将两个运算对象连接在一起，也只能出现在带参宏定义的文本替换中。 #define STR(s) #s #define COMB(str1,str2) str1##str2 int main() { int UART1= 57600; printf(\"%d\\n\", COMB(UART, 1)); printf(\"%s\\n\", STR(3.1415)); return 0; }","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://tqoqt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://tqoqt.github.io/tags/C%E8%AF%AD%E8%A8%80/"}],"author":"张君韵"},{"title":"C语言进阶学习","slug":"2022-01-05-C语言进阶学习","date":"2022-01-03T01:00:00.000Z","updated":"2022-01-05T16:14:55.977Z","comments":true,"path":"posts/c.html","link":"","permalink":"https://tqoqt.github.io/posts/c.html","excerpt":"","text":"1、指针1.1普通整型变量int i; 从i开始，先与之结合，i是一个指针。再和int结合，说明指针所指向的内容的类型为int型，所以i是一个返回整型数据的指针 1.2数组int i[3] 从i开始，先和[]结合，得i是数组，然后与int结合，说明数组里的元素是整型的，所以i是一个由整型数据组成的数组 1.3返回指针的数组int *i[3] 从i开始，先与[]结合，因为其优先级高，所以i是一个数组。然后再结合，说明数组里的元素是指针类型。再和int结合，说明指针指向的内容的类型是整型的，所以i是一个由返回整型数据的指针所组成的数组。 1.4指向数据的指针int (*i)[3] 先在i结合，说明i是一个指针。再和[]结合，说明指针指向的内容是一个数组。之后再和int结合，说明数组里的元素是整型的，所以i是一个指向由由整型数据组成3个整数的指针 1.5指向指针的指针int **i 先从i开始，先结合成一个指针，然后再结合说明指针指向的元素是指针。再和int结合，说明该指针指向的元素是整型数据。 1.6返回值是整型数据int i(int) 从i开始，先和()结合，说明i是一个函数。然后进入()分析,说明该函数有一个整型变量的参数，之后再和外面的int结合，说明函数的返回值是一个整型数据 1.7有一个整型参数且返回类型为整型的指针int (*i)(int) 从i处开始，先与指针结合，说明i是一个指针。然后与()结合，说明指针指向的是一个函数。之后再与()里的int结合，说明函数有一个int型的参数，再与最外层的int结合，说明函数的返回类型是整型，所以i是一个指向有一个整型参数且返回类型为整型的函数的指针。 2、指针的值即指针所指向的内存区或地址。 指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。 在32位程序里，所有类型的指针的值都是一个32位整数，因为32位程序里内存地址全都是32位长。指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为si zeof(指针所指向的类型)的一片内存区。 以后，我们说一个指针的值是XX，就相当于说该指针指向了以XX为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。 指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在例一中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。 以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指的类型是什么？该指针指向了哪里？ 3、指针本身所占据的内存区指针本身占了多大的内存？只要用函数sizeof(指针的类型)测一下就知道了。在32位平台里，指针本身占据4个字节的长度。指针本身占据的内存这个概念在判断一个指针表达式是否是左值时很有用。 4、结构体1、结构体作用(1) 有机地组织了对象的属性。比如，在STM32的RTC开发中，我们需要数据来表示日期和时间，这些数据通常是年、月、日、时、分、秒。如果我们不用结构体，那么就需要定义6个变量来表示。这样的话程序的数据结构是松散的，我们的数据结构最好是“高内聚，低耦合”的。所以，用一个结构体来表示更好，无论是从程序的可读性还是可移植性还是可维护性皆是： typedef struct //公历日期和时间结构体 { vu16 year; vu8 month; vu8 date; vu8 hour; vu8 min; vu8 sec; }_calendar_obj; _calendar_obj calendar; //定义结构体变量 (2) 以修改结构体成员变量的方法代替了函数(入口参数)的重新定义。如果说结构体有机地组织了对象的属性表示结构体“中看”，那么以修改结构体成员变量的方法代替函数(入口参数)的重新定义就表示了结构体“中用”。继续以上面的结构体为例子，我们来分析。假如现在我有如下函数来显示日期和时间： void DsipDateTime( _calendar_obj DateTimeVal) 那么我们只要将一个_calendar_obj这个结构体类型的变量作为实参调用DsipDateTime()即可，DsipDateTime()通过DateTimeVal的成变量来实现内容的显示。如果不用结构体，我们很可能需要写这样的一个函数： void DsipDateTime( vu16 year，vu8 month，vu8 date，vu8 hour，vu8 min，vu8 sec) 显然这样的形参很不可观，数据结构管理起来也很繁琐。如果某个函数的返回值得是一个表示日期和时间的数据，那就更复杂了。这只是一方面。 另一方面，如果用户需要表示日期和时间的数据中还要包含星期(周)，这个时候，如果之前没有用机构体，那么应该在DsipDateTime()函数中在增加一个形参vu8 week： void DsipDateTime( vu16 year，vu8 month，vu8 date，vu8 week，vu8 hour，vu8 min，vu8 sec) 可见这种方法来传递参数非常繁琐。所以以结构体作为函数的入口参数的好处之一就是函数的声明void DsipDateTime(_calendar_obj DateTimeVal)不需要改变，只需要增加结构体的成员变量，然后在函数的内部实现上对calendar.week作相应的处理即可。这样，在程序的修改、维护方面作用显著。 typedef struct //公历日期和时间结构体 { vu16 year; vu8 month; vu8 date; vu8 week; vu8 hour; vu8 min; vu8 sec; }_calendar_obj; _calendar_obj calendar; //定义结构体变量 (3) 结构体的内存对齐原则可以提高CPU对内存的访问速度(以空间换取时间)。并且，结构体成员变量的地址可以根据基地址(以偏移量offset)计算。我们先来看看下面的一段简单的程序，对于此程序的分析会在第2部分结构体成员变量内存对齐中详细说明。 #include&lt;stdio.h&gt; int main() { struct //声明结构体char_short_long { char c; short s; long l; }char_short_long; struct //声明结构体long_short_char { long l; short s; char c; }long_short_char; struct //声明结构体char_long_short { char c; long l; short s; }char_long_short; printf(\" \\n\"); printf(\" Size of char = %d bytes\\n\",sizeof(char)); printf(\" Size of shrot = %d bytes\\n\",sizeof(short)); printf(\" Size of long = %d bytes\\n\",sizeof(long)); printf(\" \\n\"); //char_short_long printf(\" Size of char_short_long = %d bytes\\n\",sizeof(char_short_long)); printf(\" Addr of char_short_long.c = 0x%p (10进制：%d)\\n\",&amp;char_short_long.c,&amp;char_short_long.c); printf(\" Addr of char_short_long.s = 0x%p (10进制：%d)\\n\",&amp;char_short_long.s,&amp;char_short_long.s); printf(\" Addr of char_short_long.l = 0x%p (10进制：%d)\\n\",&amp;char_short_long.l,&amp;char_short_long.l); printf(\" \\n\"); printf(\" \\n\"); //long_short_char printf(\" Size of long_short_char = %d bytes\\n\",sizeof(long_short_char)); printf(\" Addr of long_short_char.l = 0x%p (10进制：%d)\\n\",&amp;long_short_char.l,&amp;long_short_char.l); printf(\" Addr of long_short_char.s = 0x%p (10进制：%d)\\n\",&amp;long_short_char.s,&amp;long_short_char.s); printf(\" Addr of long_short_char.c = 0x%p (10进制：%d)\\n\",&amp;long_short_char.c,&amp;long_short_char.c); printf(\" \\n\"); printf(\" \\n\"); //char_long_short printf(\" Size of char_long_short = %d bytes\\n\",sizeof(char_long_short)); printf(\" Addr of char_long_short.c = 0x%p (10进制：%d)\\n\",&amp;char_long_short.c,&amp;char_long_short.c); printf(\" Addr of char_long_short.l = 0x%p (10进制：%d)\\n\",&amp;char_long_short.l,&amp;char_long_short.l); printf(\" Addr of char_long_short.s = 0x%p (10进制：%d)\\n\",&amp;char_long_short.s,&amp;char_long_short.s); printf(\" \\n\"); return 0; } 程序的运行结果如下(注意：括号内的数据是成员变量的地址的十进制形式)： 2. 结构体成员变量内存对齐首先，我们来分析一下上面程序的运行结果。前三行说明在我的程序中，char型占1个字节，short型占2个字节，long型占4个字节。char_short_long、long_short_char和char_long_short是三个结构体成员相同但是成员变量的排列顺序不同。并且从程序的运行结果来看， Size of char_short_long = 8 bytes Size of long_short_char = 8 bytes Size of char_long_short = 12 bytes //比前两种情况大4 byte ！ 并且，还要注意到，1 byte (char)+ 2 byte (short)+ 4 byte (long) = 7 byte，而不是8 byte。 所以，结构体成员变量的放置顺序影响着结构体所占的内存空间的大小。一个结构体变量所占内存的大小不一定等于其成员变量所占空间之和。如果一个用户程序或者操作系统(比如uC/OS-II)中存在大量结构体变量时，这种内存占用必须要进行优化，也就是说，结构体内部成员变量的排列次序是有讲究的。 结构体成员变量到底是如何存放的呢？ 原则1 结构（struct或联合union）的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小的整数倍开始（比如int在32位机为4字节，则要从4的整数倍地址开始存储）。 原则2 结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的整数倍，不足的要补齐。 原则3 结构体作为成员时，结构体成员要从其内部最大元素大小的整数倍地址开始存储。（struct a里存有struct b，b里有char，int，double等元素时，那么b应该从8的整数倍地址处开始存储，因为sizeof(double) = 8 bytes） 先看看char_short_long和long_short_char这两个结构体，从它们的成员变量的地址可以看出来，这两个结构体符合原则1和原则2。注意，在 char_short_long的成员变量的地址中，char_short_long.s的地址是1244994，也就是说，1244993是“空的”，只是被“占位”了！ 成员变量 成员变量十六进制地址 成员变量十进制地址 char_long_short.c 0x0012FF2C 1244972 char_long_short.l 0x0012FF30 1244976 char_long_short.s 0x0012FF34 1244980 可见，其内存分布图如下，共12 bytes： 首先，1244972能被1整除，所以char_long_short.c放在1244972处没有问题(其实，就char型成员变量自身来说，其放在任何地址单元处都没有问题)，根据原则1，在之后的1244973~1244975中都没有能被4(因为sizeof(long)=4bytes)整除的，1244976能被4整除，所以char_long_short.l应该放在1244976处，那么同理，最后一个.s(sizeof(short)=2 bytes)是应该放在1244980处。 是不是这样就结束了？不是，还有原则2。根据原则2的要求，char_long_short这个结构体所占的空间大小应该是其占内存空间最大的成员变量的大小的整数倍。如果我们到此就结束了，那么char_long_short所占的内存空间是12449721244981共计10bytes，不符合原则2，所以，必须在最后补齐2个 bytes(12449821244983)。 至此，一个结构体的内存布局完成了。 下面我们按照上述原则，来验证这样的分析是不是正确。按上面的分析，地址单元1244973、1244974、1244975以及1244982、1244983都是空的(至少char_long_short未用到，只是“占位”了)。如果我们的分析是正确的，那么，定义这样一个结构体，其所占内存也应该是12 bytes： struct //声明结构体char_long_short_new { char c; char add1; //补齐空间 char add2; //补齐空间 char add3; //补齐空间 long l; short s; char add4; //补齐空间 char add5; //补齐空间 }char_long_short_new;","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://tqoqt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"C语言指针","slug":"C语言指针","permalink":"https://tqoqt.github.io/tags/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/"}],"author":"张君韵"},{"title":"","slug":"考编","date":"2021-12-28T15:17:29.560Z","updated":"2022-01-03T15:21:33.370Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://tqoqt.github.io/posts/0.html","excerpt":"","text":"考编一、近代史graph LR A[侵略线]--&gt;B(第一次鸦片战争) A[侵略线]--&gt;C(第二次鸦片战争) A[侵略线]--&gt;D(甲午中日战争战争) A[侵略线]--&gt;E(八国联军侵华) 1、时间线1840-&gt;1919年5月4号-&gt;19491.1、五四运动之前为旧民主主义革命时期， 1.2、五四运动之后为新民主主义革命时期， 1.3、这么分是因为领导阶级的不同 2、内容2.1、侵略线​ 2.1.1第一次鸦片战争(清政府-英国：1840，签订南京条约，近代史第一个不平等条约) ​ 2.1.2第二次鸦片战争（清政府-英法联军：1856，北京、天津条约-》英法联军火烧圆明园） ​ 2.1.3甲午中日战争（清政府-日本：马关条约） ​ 2.1.4八国联军侵华（辛丑条约–庚子赔款） 2.2、救亡线​ 2.2.1、农民阶级（太平天国、义和团，农民阶级） ​ 2.2.2、地主阶级（洋务运动） ​ 2.2.3资产阶级改良（民族资产阶级-本地-》维新变法） ​ 2.2.4、资产阶级革命（辛亥革命-孙中山的三民主义革命果实被窃取） ​ 2.2.5无产阶级和党（ ）","categories":[],"tags":[]},{"title":"","slug":"Typora绘图","date":"2021-12-23T16:00:00.000Z","updated":"2021-12-23T16:52:56.522Z","comments":true,"path":"posts/b-b.html","link":"","permalink":"https://tqoqt.github.io/posts/b-b.html","excerpt":"","text":"1、横向流程图graph LR A[方形] --&gt;B(圆角) B --&gt; C{条件a} C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[横向流程图] graph LR A[方形] --&gt;B(圆角) B --&gt; C{条件a} C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[横向流程图] 2、竖向流程图graph TD A[方形] --&gt;B(圆角) B --&gt; C{条件a} C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[竖向流程图] graph TD A[方形] --&gt;B(圆角) B --&gt; C{条件a} C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[竖向流程图] 语言写mermaid 3、标准流程图st=&gt;start: 开始框 op=&gt;operation: 处理框 cond=&gt;condition: 判断框(是或否?) sub1=&gt;subroutine: 子流程 io=&gt;inputoutput: 输入输出框 e=&gt;end: 结束框 st-&gt;op-&gt;cond cond(yes)-&gt;io-&gt;e cond(no)-&gt;sub1(right)-&gt;op st=&gt;start: 开始框 op=&gt;operation: 处理框 cond=&gt;condition: 判断框(是或否?) sub1=&gt;subroutine: 子流程 io=&gt;inputoutput: 输入输出框 e=&gt;end: 结束框 st-&gt;op-&gt;cond cond(yes)-&gt;io-&gt;e cond(no)-&gt;sub1(right)-&gt;op 语言写flow 4、横向图st=&gt;start: 开始框 op=&gt;operation: 处理框 cond=&gt;condition: 判断框(是或否?) sub1=&gt;subroutine: 子流程 io=&gt;inputoutput: 输入输出框 e=&gt;end: 结束框 st(right)-&gt;op(right)-&gt;cond cond(yes)-&gt;io(bottom)-&gt;e cond(no)-&gt;sub1(right)-&gt;op st=&gt;start: 开始框 op=&gt;operation: 处理框 cond=&gt;condition: 判断框(是或否?) sub1=&gt;subroutine: 子流程 io=&gt;inputoutput: 输入输出框 e=&gt;end: 结束框 st(right)-&gt;op(right)-&gt;cond cond(yes)-&gt;io(bottom)-&gt;e cond(no)-&gt;sub1(right)-&gt;op 语言写flow 5、UML简单时序图对象A-&gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--&gt;对象A: 我很好(响应) 对象A-&gt;对象B: 你真的好吗？ 对象A-&gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--&gt;对象A: 我很好(响应) 对象A-&gt;对象B: 你真的好吗？ 语言写sequence 6、UML复杂时序图Title: 标题：复杂使用 对象A-&gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--&gt;对象A: 我很好(响应) 对象B-&gt;小三: 你好吗 小三--&gt;&gt;对象A: 对象B找我了 对象A-&gt;对象B: 你真的好吗？ Note over 小三,对象B: 我们是朋友 participant C Note right of C: 没人陪我玩 Title: 标题：复杂使用 对象A-&gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--&gt;对象A: 我很好(响应) 对象B-&gt;小三: 你好吗 小三--&gt;&gt;对象A: 对象B找我了 对象A-&gt;对象B: 你真的好吗？ Note over 小三,对象B: 我们是朋友 participant C Note right of C: 没人陪我玩 7、UML标准时序图样例%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头 sequenceDiagram participant 张三 participant 李四 张三-&gt;王五: 王五你好吗？ loop 健康检查 王五-&gt;王五: 与疾病战斗 end Note right of 王五: 合理 食物 &lt;br/&gt;看医生... 李四--&gt;&gt;张三: 很好! 王五-&gt;李四: 你怎么样? 李四--&gt;王五: 很好! %% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头 sequenceDiagram participant 张三 participant 李四 张三-&gt;王五: 王五你好吗？ loop 健康检查 王五-&gt;王五: 与疾病战斗 end Note right of 王五: 合理 食物 &lt;br/&gt;看医生... 李四--&gt;&gt;张三: 很好! 王五-&gt;李四: 你怎么样? 李四--&gt;王五: 很好! 语言写mermaid 8、甘特图样例%% 语法示例 gantt dateFormat YYYY-MM-DD title 软件开发甘特图 section 设计 需求 :done, des1, 2014-01-06,2014-01-08 原型 :active, des2, 2014-01-09, 3d UI设计 : des3, after des2, 5d 未来任务 : des4, after des3, 5d section 开发 学习准备理解需求 :crit, done, 2014-01-06,24h 设计框架 :crit, done, after des2, 2d 开发 :crit, active, 3d 未来任务 :crit, 5d 耍 :2d section 测试 功能测试 :active, a1, after des3, 3d 压力测试 :after a1 , 20h 测试报告 : 48h %% 语法示例 gantt dateFormat YYYY-MM-DD title 软件开发甘特图 section 设计 需求 :done, des1, 2014-01-06,2014-01-08 原型 :active, des2, 2014-01-09, 3d UI设计 : des3, after des2, 5d 未来任务 : des4, after des3, 5d section 开发 学习准备理解需求 :crit, done, 2014-01-06,24h 设计框架 :crit, done, after des2, 2d 开发 :crit, active, 3d 未来任务 :crit, 5d 耍 :2d section 测试 功能测试 :active, a1, after des3, 3d 压力测试 :after a1 , 20h 测试报告 : 48h 语言写mermaid","categories":[{"name":"软件篇","slug":"软件篇","permalink":"https://tqoqt.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%AF%87/"}],"tags":[],"author":"张君韵"},{"title":"工具备注","slug":"office破解","date":"2021-12-14T15:17:00.000Z","updated":"2021-12-14T16:16:22.922Z","comments":true,"path":"posts/office.html","link":"","permalink":"https://tqoqt.github.io/posts/office.html","excerpt":"","text":"选择部署 我选择365应用企业版，看个人需要，应用程序按需求选取，体系结构选取32位，其他不用变化 开始部署 选择是开始部署 部署完点进查看 使用其他账户创建新账户按要求填写到账户登入到账户未激活 先选择清楚所有许可证 清除完后点击安装许可证到 到出现产品密钥安装成功 点击右上角激活 出现下列情况 重复清除许可证、安装许可证、激活操作","categories":[{"name":"工具","slug":"工具","permalink":"https://tqoqt.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Office","slug":"Office","permalink":"https://tqoqt.github.io/tags/Office/"},{"name":"破解","slug":"破解","permalink":"https://tqoqt.github.io/tags/%E7%A0%B4%E8%A7%A3/"}],"author":"张君韵"},{"title":"","slug":"C语言代码规范","date":"2021-12-09T16:35:01.554Z","updated":"2021-12-09T16:38:43.136Z","comments":true,"path":"posts/c-c.html","link":"","permalink":"https://tqoqt.github.io/posts/c-c.html","excerpt":"","text":"总体原则:1)清晰第一:​ 见名知意，有完整的功能注释及用法。 2)简洁为美:​ 一个函数-一个功能，尽量在50行代码完成-一个逻辑。 3)风格统一:选择合适的风格，保存代码风格统- 。 1、头文件原则1.1头文件中适合放置接口的声明，不适合放置实现。说明:头文件是模块(Module)或单元(Unit)的对外接口。头文件中应放置对外部的声明，如对外提供的函数声明、宏定义、类型定义等。 原则1.2头文件应当职责单一说明:头文件过于复杂，依赖过于复杂是导致编译时间过长的主要原因。很多现有代码中头文件过大，职责过多，再加上循环依赖的问题，可能导致为了在.c中使用一个宏，而包含十几个头文件。 原则1.3头文件应向稳定的方向包含说明:头文件的包含关系是一种依赖，一 般来说， 应当让不稳定的模块依赖稳定的模块，从而当不稳定的模块发生变化时，不会影响(编译)稳定的模块。 产品依赖于平台，平台依赖于标准库。 除了不稳定的模块依赖于稳定的模块外，更好的方式是两个模块共同依赖于接口。 规则1.1编写.C 和.H说明:每一个.c文件应有一-个同名.h文件，如果-一个.c文件不需要对外公布任何接口，则其就不应当存在，除非它是程序的入口，如main函数所在的文件。 规则1.2编写内部保护符说明:总是编写内部#include保护符(#define 保护)，多次包含-一个头文件可以通过认真的设计来避免。如果不能做到这一一点，就需要采取阻止头文件内容被包含多于- -次的机制。 规则1.3.编写头文件应当自包含说明:简单的说，自包含就是任意一一个头文件均可独 立编译.如果- -个文件包含某个头文件，还要包含另外- -个头文件才能工作的话，就会增加交流障碍，给这个头文件的用户增添不必要的负担。 规则1.4禁止在头文件中定义变量说明:在头文件中定义变量，将会由于头文件被其他.c文件包含而导致变量重复定义。 规则1.5禁止头文件循环依赖说明:头文件循环依赖，指a.h包含b.h, b.h包含c.h， c.h 包含a.h之类导致任何一个头文件修改，都导致所有包含了a.h/b.h/c.h 的代码全部重新编译一遍。 而如果是单向依赖，如a.h包含b.h, b.h包含c.h,而c.h不包含任何头文件，则修改a.h不会导致包含了b.h/c.h 的源代码重新编译。 规则1.6禁止包含用不到的头文件说明: /.h 文件禁止包含用不到的头文件，很多系统中头文件包含关系复杂，开发人员为了省事起见，可能不会去一- -钻研， 直接包含- - 切想到的头文件，甚至有些产品干脆发布了一个god.h,其中包含了所有头文件，然后发布给各个项目组使用，这种只图一时省事的做法，导致整个系统的编译时间进一步 恶化，并对后来人的维护造成了巨大的麻烦。 规则1.7禁止在.c中使用extern说明:在.c中通过exterm的方式使用外部函数接口或变量，只能通过包含头文件的方式使用其他.c提供的接口,若a.c使用了b.c 定义的foo()函数，则应当在b.h中声明extern int foo(intinput);并在a.c中通过#include. 2、函数函数设计的精髓:编写整洁函数，同时把代码有效组织起来。 原则2.1一函数一功能说明:一个函数仅完成一-件功能，一个函数实现多个功能给开发、使用、维护都带来很大的困难。 原则2.2代码提炼说明:重复代码应该尽可能提炼成函数，重复代码提炼成函数可以带来维护成本的降低。 规则2.1避免函数超50行说明:避免函数过长，新增函数不超过50行(非空非注释行)。本规则仅对新增函数做要求，对已有函数修改时，建议不增加代码行。 规则2.2避免超4嵌套说明:避免函数的代码块嵌套过深，新增函数的代码块嵌套不超过4层，本规则仅对新增函数做要求，对已有的代码建议不增加嵌套层次。 规则2.3避免重共享变量说明:可重入函数应避免使用共享变量:若需要使用，则应通过互斥手段(关中断、信号量)对其加以保护。可重入函数是指可能被多个任务并发调用的函数。在多任务操作系统中，函数具有可重入性是多个任务可以共用此函数的必要条件。共享变量指的全局变量和static变量。 规则2.4处理参数合法性检查说明:由调用者负责还是由接口函数负责，应在项目组/模块内应统–规定。缺省由调用者负责。对于模块间接口函数的参数的合法性检查这- -问题，往往有两个极端现象，即:要么是调用者和被调用者对参数均不作合法性检查,结果就遗漏了合法性检查这一-必要的处理过程，造成问题隐患:要么就是调用者和被调用者均对参数进行合法性检查，这种情况虽不会造成问题，但产生了冗余代码，降低了效率。 规则2.5处理错误码说明:对函数的错误返回码要全面处理。-一个函数(标准库中的函数/第三方库函数/用户定义的函数)能够提供一些指示错误发 生的方法。这可以通过使用错误标记、特殊的返回数据或者其他手段，不管什么时候函数提供了这样的机制，调用程序应该在函数返回时立刻检查错误指示。 规则2.6处理扇入扇出说明:设计高扇入，合理扇出(小于7)的函数。扇出是指-一个函数直接调用(控制)其它函数的数目，而扇入是指有多少上级函数调用它。 规则2.7处理废弃代码说明:废弃代码(没有被调用的函数和变量)要及时清除。程序中的废弃代码不仅占用额外的空间，而且还常常影响程序的功能与性能，很可能给程序的测试、维护等造成不必要的麻烦。 代码的建议建议2.1不变参数应固定说明:函数不变参数使用const.不变的值更易于理解/跟踪和分析，把const作为默认选项，在编译时会对其进行检查，使代码更牢固/更安全。 建议2.2函数变量应临时说明:函数应避免使用全局变量、静态局部变量和1/0操作，不可避免的地方应集中使用。带有内部“存储器”的函数的功能可能是不可预测的，因为它的输出可能取决于内部存储器(如某标记)的状态。这样的函数既不易于理解又不利于测试和维护。在C语言中，函数的static局部变量是函数的内部存储器，有可能使函数的功能不可预测，然而，当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类，则返回为错针。 建议2.3有效性参数应检查说明:检查函数所有非参数输入的有效性，如数据文件、公共变量等。 函数的输入主要有两种: -种是参数输入: 另一种是全局变量、数据文件的输入，即非参数输入。函数在使用输入参数之前，应进行有效性检查。 建议2.4参数个数应少5说明:函数的参数个数不超过5 个。函数的参数过多，会使得该函数易于受外部(其他部分的代码)变化的影响，从而影响维护工作。函数的参数过多同时也会增大测试的工作量。 建议2.5参数长度应固定说明:除打印类函数外，不要使用可变长参函数。可变长参函数的处理过程比较复杂容易引入错误，而且性能也比较低，使用过多的可变长参函数将导致函数的维护难度大大增加。 建议2.6非外用应静态说明:在源文件范围内声明和定义的所有函数，除非外部可见，否则应该增加static关键字。如果一个函数只是在同一文件中的其他地方调用，那么就用static声明。使用static确保只是在声明它的文件中是可见的，并且避免了和其他文件或库中的相同标识符发生混淆的可能性。 建议2.7规范应统一a. 小写字母开头大写字母链接间隔区分，如uteHalayerxxx. b. 函數开头包含函数主体名，如ute_ hal layer.c, 里面的函数都用uteHalLayer开头。格式为:文件主体名+功能名。","categories":[{"name":"技巧篇","slug":"技巧篇","permalink":"https://tqoqt.github.io/categories/%E6%8A%80%E5%B7%A7%E7%AF%87/"}],"tags":[],"author":"张君韵"},{"title":"Arduino_ESP32开发","slug":"Arduino开发语言","date":"2021-12-05T16:00:00.000Z","updated":"2021-12-05T16:22:15.990Z","comments":true,"path":"posts/rtt1.html","link":"","permalink":"https://tqoqt.github.io/posts/rtt1.html","excerpt":"","text":"1、关键字;;是一条语句结束的标志，供编译器识别，必须得有。 {}{}将多条语句合成一个复合语句，能划分语句的作用域，增强整体整体的可读性。 ////行注释，该行//后的所有语句，文字将不被编译器所编译、执行。相似的，还有，在中的所有语句，文字将不被编译器所编译、执行。 ifif(表达式){语句A;} if_else if_elseif(表达式1){语句1；}else if(表达式2){语句2；}…else if(表达式n){语句n；}else{语句n+1；} forfor(初始表达式；条件表达式；循环变量表达式){循环体语句；} switch_case_defaultswitch(表达式){case 表达式常量1:语句序列1；case 表达式常量2:语句序列2；…case 表达式常量i:语句序列i；case 表达式常量n:语句序列n；default:语句序列n+1；} whilewhile(条件表达式){循环语句；循环变量表达式；} do_whiledo{循环体语句；}while(条件表达式); 2、数据类型3、常量HIGH | LOW 表示数字IO口的高低电平。HIGH 表示高电（1），LOW 表示低电平（0）。INPUT | OUTPUT 表示数字IO口的方向，INPUT 表示输入（高阻态），OUTPUT 表示输出（AVR单片机能提供5V电压 40mA电流）。true | false true 表示真（1），false表示假（0）。 4、程序结构声明变量及接口名称（例如：int i;int ledPin=13;）。void setup() 函数在程序开始时使用，初始化变量，管脚模式，调用库函数等（例如：pinMode(ledPin,OUTUPT);）。相当于main（）函数中while函数之前的作用 void loop() 在void setup()函数之后，即初始化之后，loop() 让你的程序循环地被执行。使用它来运转Arduino。相当于while（）函数 5、 数字 I/O以下型号为UNO pinMode(pin, mode);数字IO口输入输出模式定义函数，pin表示为0～13， mode表示INPUT或OUTPUT。 digitalWrite(pin, value) ;数字IO口输出电平定义函数，pin表示为0～13，value表示为HIGH或LOW。必须先定义为输入或输出模式digitalWrite才能生效。 int digitalRead(pin);数字IO口读输入电平函数，pin表示为0～13，value表示为HIGH或LOW。比如可以读数字传感器。 6、 模拟IOint analogRead(pin);模拟IO口读函数，pin表示为0～5（ArduinoDiecimila为0～5，Arduino nano为0～7）。比如可以读模拟传感器（10位AD，0～5V表示为0～1023）。 analogWrite(pin, value) - PWM数字IO口PWM输出函数，Arduino数字IO口标注了PWM的IO口可使用该函数通常在引脚的旁边标注~，pin表示3, 5, 6, 9,10, 11，value表示为0～255。比如可用于电机PWM调速或音乐播放。 7.、扩展 I/OshiftOut(dataPin, clockPin, bitOrder,value)；SPI外部IO扩展函数，通常使用带SPI接口的74HC595做8个IO扩展，dataPin为数据口，clockPin为时钟口，bitOrder为数据传输方向（MSBFIRST高位在前，LSBFIRST低位在前），value表示所要传送的数据（0～255），另外还需要一个IO口做74HC595的使能控制。 unsigned long pulseIn(pin, value)；脉冲长度记录函数，返回时间参数（us），pin表示为0～13，value为HIGH或LOW。比如value为HIGH，那么当pin输入为高电平时，开始计时，当pin输入为低电平时，停止计时，然后返回该时间。 8、时间函数unsigned long millis()；返回时间函数（单位ms），该函数是指，当程序运行就开始计时并返回记录的参数，该参数溢出大概需要50天时间。 delay(ms)；延时函数（单位ms）。 delayMicroseconds(us)；延时函数（单位us）。 9、**数学函数**min(x, y) ;求最小值。 max(x, y) ;求最大值。 abs(x) ; 计算绝对值。 constrain(x, a, b) ;约束函数，下限a，上限b，x必须在ab之间才能返回。 map(value, fromLow, fromHigh, toLow,toHigh);约束函数，value必须在fromLow与toLow之间和fromHigh与toHigh之间。 pow(base, exponent);开方函数，base的exponent次方。 sq(x); 平方。 sqrt(x);开根号。三角函数：sin(rad);cos(rad);tan(rad); 10、**随机数函数**randomSeed(seed)；随机数端口定义函数，seed表示读模拟口analogRead(pin)函数 。 long random(max)；随机数函数，返回数据大于等于0，小于max。 long random(min, max)；随机数函数，返回数据大于等于min，小于max。 11、外部中断函数attachInterrupt(interrupt, , mode；外部中断只能用到数字IO口2和3，interrupt表示中断口初始0或1，表示一个功能函数，mode：LOW低电平中断，CHANGE有变化就中断，RISING上升沿中断，FALLING 下降沿中断。 detachInterrupt(interrupt)；中断开关，interrupt=1 开，interrupt=0 关。 interrupts()；中断使能函数，用于使能中断。 noInterrupts()；中断禁止函数，禁止中断。 12、串口收发函数Serial.begin(speed)；串口定义波特率函数，speed表示波特率（串行每秒传输数据位数的速率），如9600，19200等。int Serial.available() 判断缓冲器状态。int Serial.read()；读串口并返回收到参数。Serial.flush()；清空缓冲器。Serial.print(data)；串口输出数据。Serial.print(数据，数据的进制) 默认为十进制（DEC）Serial.println(data)；串口输出数据并带回车符。","categories":[{"name":"开发语言","slug":"开发语言","permalink":"https://tqoqt.github.io/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"keil","slug":"keil","permalink":"https://tqoqt.github.io/tags/keil/"},{"name":"Arduino","slug":"Arduino","permalink":"https://tqoqt.github.io/tags/Arduino/"}],"author":"张君韵"},{"title":"ESP32学习","slug":"ESP32","date":"2021-11-10T01:00:00.000Z","updated":"2021-11-23T16:42:10.665Z","comments":true,"path":"posts/esp32.html","link":"","permalink":"https://tqoqt.github.io/posts/esp32.html","excerpt":"","text":"ESP32软件ESP IDF 1.ESP32单片机开发框架Arduino单片机底层 Micropythonhttp://www.micropython.org 分布式版本控制每个人拥有全部代码，可以存储在本地，有网时上传到服务器中 2.环境配置1、VScode+platformlO IDE2、VScode+Arduino最终选择VScode+PLatformlo IDE配置开发环境 3、程序1、点亮LED灯void setup() { // put your setup code here, to run once: pinMode(D4,OUTPUT); } void loop() { // put your main code here, to run repeatedly: digitalWrite(D4,HIGH); delay(200); digitalWrite(D4,LOW); delay(200); } ２、连接ＷＩＦＩ打印IP#include &lt;ESP8266WiFi.h&gt; //获取ESP8266连接的WIFI的IP const char* ssid = \"Xiaomi_69FC\"; const char* password = \"502niubi.\"; void setup() { // put your setup code here, to run once: Serial.begin(115200); WiFi.begin(ssid,password); while(WiFi.status() != WL_CONNECTED) { delay(500); Serial.println(\".\"); } Serial.println(\"\"); Serial.println(\"WiFi connected\"); Serial.println(WiFi.localIP()); } void loop() { // put your main code here, to run repeatedly: } ３、获取百度网页源代码#include &lt;WiFi.h&gt; //wifi参数 const char* ssid = \"zsf\"; const char* password = \"123456789\"; //Host const char* host = \"www.baidu.com\"; void setup() { // put your setup code here, to run once: Serial.begin(115200); Serial.println(); Serial.println(); Serial.print(\"Connecting to \"); Serial.println(ssid); WiFi.begin(ssid,password); while(WiFi.status() != WL_CONNECTED) { delay(500); Serial.print(\".\"); } Serial.println(\"\"); Serial.println(\"WiFi connected\"); Serial.println(\"IP address: \"); Serial.println(WiFi.localIP()); } int value = 0; void loop() { // put your main code here, to run repeatedly: Serial.print(\"Connecting to \"); Serial.println(host); //使用WIFIClient类创建TCP连接 WiFiClient client; const int httpPort = 80; if(!client.connect(host,httpPort)) { Serial.println(\"connection failed\"); return; } client.print(String(\"GET /\") + \" HTTP/1.1\\r\\n\" + \"Host: \" + host + \"\\r\\n\" + \"Connection: close\\r\\n\\r\\n\"); delay(200); while(client.available()) { String line = client.readStringUntil('\\r'); Serial.print(line); } Serial.println(); Serial.println(\"closing connection\"); delay(500); }","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://tqoqt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"ESP32","slug":"ESP32","permalink":"https://tqoqt.github.io/tags/ESP32/"}],"author":"张君韵"},{"title":"RT_Thread Nano移植到Keil","slug":"操作系统Nano","date":"2021-10-27T16:00:00.000Z","updated":"2021-10-29T12:09:51.853Z","comments":true,"path":"posts/rtt1.html","link":"","permalink":"https://tqoqt.github.io/posts/rtt1.html","excerpt":"","text":"前言 Internal command error 修改board.c中的USART要选对串口才能下载成功出现功能 1、报错1.1、Error: L6218E: Undefined symbol rt_thread_create (r1.1.1在让他从fig.h中找到#define RT_USING_HEAP去除注释2、功能开启动态线程，要打开rtconfig.h中的#define RT_USING_HEAP 与裸机 LED 闪烁应用代码的不同： 1). 延时函数不同： RT-Thread 提供的 rt_thread_mdelay() 函数可以引起操作系统进行调度，当调用该函数进行延时时，本线程将不占用 CPU，调度器切换到系统的其他线程开始运行。而裸机的 delay 函数是一直占用 CPU 运行的。 2). 初始化系统时钟的位置不同：移植好 RT-Thread Nano 之后，不需要再在 main() 中做相应的系统配置（如 hal 初始化、时钟初始化等），这是因为 RT-Thread 在系统启动时，已经做好了系统时钟初始化等的配置，这在上一小节 “系统时钟配置” 中有讲解。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://tqoqt.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"keil","slug":"keil","permalink":"https://tqoqt.github.io/tags/keil/"},{"name":"RT_Thread","slug":"RT-Thread","permalink":"https://tqoqt.github.io/tags/RT-Thread/"}],"author":"张君韵"},{"title":"","slug":"代码规范","date":"2021-10-26T16:00:00.000Z","updated":"2021-10-27T09:19:17.608Z","comments":true,"path":"posts/dai-ma-gui-fan.html","link":"","permalink":"https://tqoqt.github.io/posts/dai-ma-gui-fan.html","excerpt":"","text":"代码规范1、总体原则 简洁明了 清晰 和原有风格保持一致 2、头文件 头文件职责单一，切忌依赖复杂：如不能包含过多头文件 每一个C文件应有一个同名的H文件，用于声明需对外公开的接口 禁止头文件循环依赖，只能是单向依赖 禁止包含用不到的头文件 头文件应当自包含，不需要别的头文件才能编译 禁止在头文件中定义变量 只能通过包含头文件的方式使用其他C文件提供的接口，禁止在C文件中通过extern的方式使用外部函数接口、变量 禁止在extern “C”中包含头文件 3、函数 一个函数仅完成一个功能 重复代码应该尽可能提炼成函数 函数避免过长 函数代码嵌套过深（尽量不超过四层） 可重入函数（可能被多个任务并发调用的函数）避免使用共享变量；如需使用，则应通过互斥手段（关中断、信号量）对其加以保护 设计高扇入，合理扇出的函数（小于七）：扇出指一个函数直接调用（控制）其他函数的数目，扇入指有多少上级函数调用它 函数应避免使用全局变量、静态局部变量和I/O操作，不可避免的地方集中操作 函数的参数个数不超过5个 4、标识符命名与定义 标识符命名要清晰明了、尽量使用完整的单词或大家都能理解的缩写 除常用通用的缩写外，不得使用单词缩写和汉语拼音，尤其拼音缩写 命名风格内部要保持一致 用反义词命名具有互斥意义的变量或相反动作的函数 尽量避免名字中出现数字编号 标识符前不添加模块、项目、产品、部门等名称作为前缀 由于不同系统对文件名大小写处理会不同，所以代码文件命名建议统一采用全小写字母命名 除头文件或编译开关等特殊标识定义，宏定义不能使用下划线开头或结尾 5、变量 一个变量只能有一个功能，不能把一个变量用作多种用途 不用或少用全局变量 局部变量与全局变量不要同名 严禁使用未经初始化的变量作为右值 尽量减少没有必要的数据类型默认转换与强制转换 6、宏、常量 用宏定义表达式时，要使用完备的括号 使用宏时，不允许参数发生变化 除非必要，应尽可能使用函数代替宏 常量建议使用const定义代替宏 #define ASPECT_RATIO 1.653 编译器会永远也看不到ASPECT_RATIO这个符号名，因为在源码进入编译器之前，它会被预处理程序去掉，于是ASPECT_RATIO不会加入到符号列表中。如果涉及到这个常量的代码在编译时报错，就会很令人费解，因为报错信息指的是1.653，而不是ASPECT_RATIO。如果ASPECT_RATIO不是在你自己写的头文件中定义的，你就会奇怪1.653是从哪里来的，甚至会花时间跟踪下去。这个问题也会出现在符号调试器中，因为同样地，你所写的符号名不会出现在符号列表中。解决这个问题的方案很简单：不用预处理宏，定义一个常量： const double ASPECT_RATIO = 1.653; 这种方法很有效，但有两个特殊情况要注意。首先，定义指针常量时会有点不同。因为常量定义一般是放在头文件中（许多源文件会包含它），除了指针所指的类型要定义成const外，重要的是指针也经常要定义成const。例如，要在头文件中定义一个基于char*的字符串常量，你要写两次const： const char * const authorName = \"Scott Meyers\"; 宏定义中尽量不使用return、goto、continue、break等改变程序流程的语句 6、表达式 函数调用不要作为另一个函数的参数使用，否则对于代码的调试、阅读都不利 赋值语句不要写在if等语句中，或作为函数的参数使用 因为if语句中，会根据条件依次判断，如果前一个条件已经可以判定整个条件，则后续条件语句不会再运行，所以可能导致期望的部分赋值没有得到运行。 用括号明确表达式的操作顺序，避免过分依赖默认优先级 7、注释 注释内容要清晰明了、含义准确，防止代码二义性 注释解释代码难以直接表达的意图，而不是重复描述代码 修改代码时，维护代码周边的所有注释，保持注释代码的一致性 文件头部应注释，注释必须列出：版权、版本号、生成日期、作者姓名、内容、功能说明、和其他文件的关系、修改日志 函数声明注释要描述函数的功能、性能及用法、输入和输出参数、函数返回值、可重入的要求 注释应放在代码上方或右方、不可放在下面，放在上方要和其上方代码用空行隔开 对于switch语句下的case语句，如果因为特殊情况需要处理完一个case后进入下一个case处理，必须在该case语句处理完、下一个case语句前加上明确的注释 注释中避免使用缩写 严禁在一行代码或表达式的中间插入注释 8、排版与格式 相对独立的程序块之间、变量说明之后必须加空行 多个短语局不允许写在同一行 if、for、do、while、case、switch、default等语句独占一行 操作符之间看情况加空格 逗号“，”封号“；”只在后面加空格 比较操作符，赋值操作符“=”、“+=”，算数操作符“+”，“%”，逻辑操作符“&amp;&amp;”、“&amp;”，位域操作符“&lt;&lt;”、“^”等双目操作符的前后加空格 “!”、”~”、”++”、”–”、“&amp;”等单目操作符前后不加空格 “-&gt;”、“.”前后不加空格 if、for、while、switch等与后面的括号间应加空格，师关键字更为突出、明显 注释符（包括/**/、//）与注释内容之间要用一个空格进行分隔 源程序中关系较为紧密的代码应尽可能相邻","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://tqoqt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"代码规范","slug":"代码规范","permalink":"https://tqoqt.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}],"author":"张君韵"},{"title":"","slug":"github访问慢","date":"2021-10-25T16:00:00.000Z","updated":"2021-10-27T11:24:16.196Z","comments":true,"path":"posts/github.html","link":"","permalink":"https://tqoqt.github.io/posts/github.html","excerpt":"","text":"github访问解决方法1、以管理员身份运行命令提示符 优化方法：绕过DNS解析，直接在**本地绑定host 2、在站长工具查询GitHub.com选择TTL值小的ＩＰ地址 ３、打开本地电脑的C:\\Windows\\System32\\drivers\\etc目录，找到ｈｏｓｔｓ文件４、文本工具在最后面打开ｈｏｓｔｓ文件在最后一行添加查询到的IP地址 ５、再在命令提示符中ｐｉｎｇ GitHub．ｃｏｍ 成功则会显示如此 最后网页打开速度会提高","categories":[{"name":"技巧篇","slug":"技巧篇","permalink":"https://tqoqt.github.io/categories/%E6%8A%80%E5%B7%A7%E7%AF%87/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://tqoqt.github.io/tags/GitHub/"}],"author":"张君韵"},{"title":"RT_Thread","slug":"操作系统","date":"2021-09-07T16:00:00.000Z","updated":"2021-10-28T11:13:28.035Z","comments":true,"path":"posts/rtt1.html","link":"","permalink":"https://tqoqt.github.io/posts/rtt1.html","excerpt":"","text":"前言 学习RT_Thread一定要坚持下去啊，为了跳槽啊！！！！！ 1、初识RT_Thread生活常见的：电视机顶盒、路由器、电冰箱、微波炉。 嵌入式操作系统是应用在嵌入式系统的软件，对接嵌入式底层硬件与上层应用。在多任务管理、任务间通信、内存管理、定时器管理、设备管理。提供一套完整的机制，极大程度上便利嵌入式应用程序的开发、管理和维护 诞生于2006年 开发环境 MDK安装 示例代码 src：RT_Thread内核代码文件 libcpu：各类芯片/内核移植代码，比如STM include：RT_Thread内核头文件 components：RT_Thread外部组件代码，比如Finsh、Lwip 简介1、特点（优势）是一个集实时操作系统内核、中间件组件和开发者社区一体的技术平台，是一个组件完整丰富、高度可伸缩、简易开发、超低功耗、高安全性的物联网操作系统。具备一个IOT OS平台所需的所有关键组件。支持市面上所有主流的编译工具如GCC、Keil、IAR等，工具链完善、友好、支持各类标准接口，几乎支持市面上所有WiFi、MCU芯片 2、概述 RT_Thread全称是Real Time-Thread，是一个嵌入式实时多线程操作系统，基本属性之一是支持多任务，在RT-Thread系统中任务是通过多线程实现的 相较于Linux操作系统，其体积小，成本低，功耗低，启动快速，而且还实时性高、占用资源小等特点，非常实用与各种资源受限的场合 一、第一章1、常见操作系统 windows、Linux、Mac 安卓操作系统、IOS 鸿蒙 2、架构与其他的RTOS如Free RTOS、uC/OS的主要区别之一是，它不仅仅是一个实时内核，还具备丰富的中间层组件 3、分类 标准版本 nano版本 是一个极简版的硬实时内核，优C语言开发，采用面向对象的编程思维，具有良好的代码风格，是一款可裁剪的、抢占式实时多任务的RTOS。其内存资源占用极小，功能包括任务处理、软件定时器、信号量、邮箱和实时调度相对完整的实时操作系统特性。 使用于家电、消费电子、医疗设备、工控等领域大量使用的32位ARM 入门级MCU场合 特点 下载简单 代码简单 移植简单 使用简单 资源占用小 开源免费 Smart版本 基于RT_Thread操作系统衍生的心分支，面向带MMU、中高端应用的芯片、例如arm Cortex_A系列芯片、MIPS芯片、带MMU的RISC-V芯片 RT_Smart在RT_Thread操作系统的基础上启用独立、完整的进程方式，同时以混合微内核模式执行 把应用从内核中独立出来，形成独立的用户态应用程序，并具备独立的地址空间 二、RT_Thread移植碰见的问题 用的Nucleo-F103RBT6的开发板，下载时碰见 解决方法：按下载前按住复位，点下载后松开复位按键 2.选择UART2可打印数据 #define BSP_CLOCK_SOURCE (\"HSI\") 选择内部晶振 外部是 #define BSP_CLOCK_SOURCE (\"HSE\") #define BSP_CLOCK_SOURCE_FREQ_MHZ ((int32_t)0) 外部晶振频率 #define BSP_CLOCK_SYSTEM_FREQ_MHZ ((int32_t)72) 内部晶振频率 int main(void) { //int count = 1; #if 0 while (count++) { LOG_D(\"Hello RT-Thread!\"); rt_thread_mdelay(1000); } #endif return RT_EOK; 这样时，打开xcome输入help可查看数据 msh &gt;help RT-Thread shell commands: clear - clear the terminal screen version - show RT-Thread version information list_thread - list thread list_sem - list semaphore in system list_event - list event in system list_mutex - list mutex in system list_mailbox - list mail box in system list_msgqueue - list message queue in system list_mempool - list memory pool in system list_timer - list timer in system list_device - list device in system help - RT-Thread shell help. ps - List threads in the system. free - Show the memory usage in the system. reboot - Reboot System 三、内核介绍内核框架1、实时内核内核库是为了保障内核能够独立运行的一套小型的类似C库的函数实现子集，这部分根据编译器的不同自带C库的情况也会有些不同，当使用GNUGCC编译器时，会携带更多的标准C库实现 实时内核的实现包括 对象管理 实时调度器 线程管理 线程间通信 时钟管理 内存管理 设备管理 内核最小的资源占用情况是3KB ROM，1.2KB RAM 2、线程调度​ 是本操作系统中最小的调度单位，是基于优先级的全占式多线程调度算法，即在系统中除了中断处理函数、调度器上锁部分的代码和禁止中断的代码时不可抢占的，其他部分都是可以抢占的。包括线程调度器本身。 ​ 支持256个线程优先级（可通过配置文件更改为最大支持32个或8个优先级，针对STM32默认配置是32个线程优先级），0表示最高优先级，最低优先级留给空闲线程使用；也支持创建多个具有相同优先级的线程。相同优先级的线程间采用时间片的轮转调度算法进行调度，使每个线程运行相应时间。 ​ 调度器在寻找处于就绪状态的具有最高优先级的线程时，所经历的时间是恒定的，系统也不限制线程数量的多少，线程数目只与硬件平台的具体内存相关。 3、时钟管理 ​ 时钟管理以时钟节拍为基础，时钟节拍是本系统最小的时钟单位。 RT_Thread的定时器提供两类定时器机制 单次触发定时器 在启动后只会触发一次定时器事件，然后定时器自动停止 周期触发定时器 会周期性的触发定时器事件，直到用户手动的停止定时器，否则将永远持续执行下去。 4、线程间同步 ​ 采用信号量、互斥量与事件集实现线程间同步 线程通过对信号量、互斥量的获取与释放进行同步 互斥量采用优先级继承的方式解决了实时系统中常见的优先级翻转问题 线程同步机制支持线程按优先级等待或按先进先出方式获取信号量或互斥量 线程通过对事件的发送与接收进行同步 事件集支持多事件的“或触发”和“与触发”，适合与线程等待多个事件的情况 5、线程通信 支持邮箱和消息队列等通信机制。邮箱长度固定为4字节大小 消息队列能够接收不固定长度的消息，并把消息缓存在自己的内存空间中 邮箱效率较消息队列更为高效。邮箱和消息队列的发送动作可安全用于中断服务例程中 通信机制支持线程按优先级等待或按先进先出方式获取 6、内存管理 支持静态内存池管理集动态内存堆管理。当静态内存池具有可用内存时，系统对内存块分配的时间将是恒定的。 当静态内存池为空时，系统将申请内存块的线程挂起或阻塞掉（即线程等待一段时间后仍为获得内存块就放弃申请并返回，或者立即返回。等待的时间取决与申请内存块时设置的等待时间参数），当其他线程释放内存块到内存池时，如果有挂起的待分配内存块的线程存在的话，则系统会将这个线程唤醒 动态内存堆管理模块在系统资源不同的情况下，分别提供了面向小内存系统的内存管理算法及面向大内存系统的SLAB内存管理算法 还有一种动态内存堆管理叫做memheap，适用于系统含有多个地址可不连续的内存堆。使用memheap可以将多个内存堆“粘连”在一起，让用户操作先是在操作一个内存堆 7、I/O设备管理​ 将PIN、I2C、SPI、USB、UART等作为外设设备，统一通过设备注册完成。实现了按名称访问的设备管理子系统，可按照统一的API界面访问硬件设备。在设备驱动接口上，根据嵌入式系统的特点，对不同的设备可以挂接相应的事件。当设备事件触发时，由驱动程序通知给上层的应用程序 内核启动流程RT-Thread 支持多种平台和多种编译器，而 rtthread_startup() 函数是 RT-Thread 规定的统一启动入口。一般执行顺序是：系统先从启动文件开始运行，然后进入 RT-Thread 的启动函数 rtthread_startup() ，最后进入用户入口函数 main()，如下图所示： ​ 流程在startup_stm32f10xxb.s中的entry中的rtthread_startup();可以查看到线程流程 tid = rt_thread_create(\"main\", main_thread_entry, RT_NULL, RT_MAIN_THREAD_STACK_SIZE, RT_MAIN_THREAD_PRIORITY, 20); 线程名字是main，线程ID是tid，线程执行函数是main_thread_entry，优先级是RT_MAIN_THRED_PRIORITY，栈的大小是RT_MAIN_THREAD_STACK_SIZE， 四、线程管理 多任务是通过多线程方式实现，线程是任务的载体，是RTT中最基本的调度单位 线程执行时的运行环境称为上下文，具体来说就是各种变量和数据，包括所有的寄存器变量、堆栈、内存信息等 线程在运行的时候，它会认为自己独占CPU运行 4.1、线程管理特点主要功能时对线程进行管理和调度，系统中总共存在两类线程，分别时系统线程和用户线程，重点放在用户线程 系统线程时由RT_Thread内核创建的线程 用户线程是由应用程序创建的线程 两类线程都会从内核对象容器中分配线程对象，当线程被删除时，也会被从对象容器中删除。 4.2、线程工作机制4.2.1、线程控制块线程控制块由结构体struct rt_thread表示，是管理线程的一个数据结构，会存放线程的一些信息，例如优先级、线程名称、线程状态，也包含线程与线程之间连接用的链表结构，线程等待事件集合 cleanup函数指针指向的函数，会在线程退出的时候，被idle线程回调一次，执行用户设置的清理现场等工作 4.2.2、线程属性 线程栈 RT_Thread线程具有独立的栈，当进行线程切换时，会将当前线程的上下文存在栈中，当线程要恢复运行时，再从栈中读取上下文信息，进行恢复 线程状态 线程优先级 最大支持256个线程优先级，数值越小优先级越高，0为最高优先级。资源紧张的系统中，可根据实际情况选择只支持8个或32个优先级的系统配置。 Cortex-M系列中普遍采用32个优先级，最低优先级默认分配给空闲线程（idle）使用，用户一般不使用。在系统中，当有比当前线程优先级更高的线程就绪时，当前线程将立刻被换出，高优先级线程抢占处理器运行 时间片 每个线程都有时间片这个参数，但时间片仅对优先级相同的就绪态线程有效 注意​ 如果一个线程中程序陷入死循环操作，则比它优先级低的线程都不能执行，所以在实时操作系统中必须注意：线程中不能陷入死循环操作，必须要有让出CPU使用权的动作，如循环中调用延时函数（进入挂起状态）或主动挂起 4.2.3、线程状态之间切换 4.2.4、系统线程RT_Thread内核中的系统线程有空闲线程和主线程 4.3、线程相关操作创建/初始化、启动、运行、删除/脱离。 动态线程：是系统自动从动态内存堆上分配空间和线程句柄（初始化heap之后才能使用create创建动态线程） 静态线程：由用户分配栈空间与线程句柄 4.3.1、动态线程rt_thread_t th1_ptr = NULL; //结构体 变量接收返回值 void th_entry(void *parameter) { while(1){ rt_kprintf(\"th_entry running...\\n\"); rt_thread_mdelay(1000); } } int main(void) { //函数名称 //入口函数 //给线程入口函数传参 //线程栈的大小 //优先级 //系统滴答时间 th1_ptr = rt_thread_create(\"th_demo\", th_entry, NULL,1024, 20, 5); if (th1_ptr == RT_NULL) { LOG_E(\"rt_thread_create failed...\\n\"); } LOG_D(\"rt_thread_create successed...\\n\"); } \\ | / - RT - Thread Operating System / | \\ 4.0.3 build Oct 28 2021 2006 - 2020 Copyright by rt-thread team \u001b[0m[D/main] rt_thread_create successed... \u001b[0m msh &gt;help RT-Thread shell commands: clear - clear the terminal screen version - show RT-Thread version information list_thread - list thread list_sem - list semaphore in system list_event - list event in system list_mutex - list mutex in system list_mailbox - list mail box in system list_msgqueue - list message queue in system list_mempool - list memory pool in system list_timer - list timer in system list_device - list device in system help - RT-Thread shell help. ps - List threads in the system. free - Show the memory usage in the system. reboot - Reboot System msh &gt;list_thread thread pri status sp stack size max used left tick error -------- --- ------- ---------- ---------- ------ ---------- --- th_demo 20 init 0x00000040 0x00000400 06% 0x00000005 000 tshell 20 running 0x000000c8 0x00001000 14% 0x0000000a 000 tidle0 31 ready 0x00000070 0x00000100 57% 0x0000000c 000 timer 4 suspend 0x0000007c 0x00000200 24% 0x00000009 000 程序下载进去后，复位就可以看到打印出来的字符串，help查看命令，list_thread查看有哪些线程 rt_thread_create（”线程名称“，入口函数，线程入口函数的传参，线程栈的大小，优先级，系统滴答时间） rt_thread_t th1_ptr = NULL; //结构体变量接收返回值 void th_entry(void *parameter) { while(1){ rt_kprintf(\"th_entry running...\\n\"); rt_thread_mdelay(1000); } } int main(void) { //函数名称 //入口函数 //给线程入口函数传参 //线程栈的大小 //优先级 //系统滴答时间 th1_ptr = rt_thread_create(\"th_demo\", th_entry, NULL,1024, 20, 5); if (th1_ptr == RT_NULL) { LOG_E(\"rt_thread_create failed...\\n\"); return RT_ENOMEM; } LOG_D(\"rt_thread_create successed...\\n\"); rt_thread_startup(th1_ptr); } \\ | / - RT - Thread Operating System / | \\ 4.0.3 build Oct 28 2021 2006 - 2020 Copyright by rt-thread team \u001b[0m[D/main] rt_thread_create successed... \u001b[0m msh &gt;th_entry running... th_entry running... th_entry running... list_thread thread pri status sp stack size max used left tick error -------- --- ------- ---------- ---------- ------ ---------- --- th_demo 20 suspend 0x000000a8 0x00000400 20% 0x00000005 000 tshell 20 running 0x000000c8 0x00001000 14% 0x00000004 000 tidle0 31 ready 0x00000070 0x00000100 57% 0x00000002 000 timer 4 suspend 0x0000007c 0x00000200 24% 0x00000009 000 因为打印th_entry running…时间是非常短的，大部分时间是在mdelay上，所以是处以挂起状态 rt_thread_startup（线程创建后赋值的） 参数 描述 name 线程的名称；线程名称的最大长度由 rtconfig.h 中的宏 RT_NAME_MAX 指定，多余部分会被自动截掉 entry 线程入口函数 parameter 线程入口函数参数 stack_size 线程栈大小，单位是字节 priority 线程的优先级。优先级范围根据系统配置情况（rtconfig.h 中的 RT_THREAD_PRIORITY_MAX 宏定义），如果支持的是 256 级优先级，那么范围是从 0~255，数值越小优先级越高，0 代表最高优先级 tick 线程的时间片大小。时间片（tick）的单位是操作系统的时钟节拍。当系统中存在相同优先级线程时，这个参数指定线程一次调度能够运行的最大时间长度。这个时间片运行结束时，调度器自动选择下一个就绪态的同优先级线程进行运行 返回 —— thread 线程创建成功，返回线程句柄 RT_NULL 线程创建失败 对于一些使用 rt_thread_create() 创建出来的线程，当不需要使用，或者运行出错时，我们可以使用下面的函数接口来从系统中把线程完全删除掉： rt_err_t rt_thread_delete(rt_thread_t thread); 调用该函数后，线程对象将会被移出线程队列并且从内核对象管理器中删除，线程占用的堆栈空间也会被释放，收回的空间将重新用于其他的内存分配。实际上，用 rt_thread_delete() 函数删除线程接口，仅仅是把相应的线程状态更改为 RT_THREAD_CLOSE 状态，然后放入到 rt_thread_defunct 队列中；而真正的删除动作（释放线程控制块和释放线程栈）需要到下一次执行空闲线程时，由空闲线程完成最后的线程删除动作。线程删除 rt_thread_delete() 接口的参数和返回值见下表： 参数 描述 thread 要删除的线程句柄 返回 —— RT_EOK 删除线程成功 -RT_ERROR 删除线程失败 4.3.2、启动线程创建（初始化）的线程状态处于初始状态，并未进入就绪线程的调度队列，我们可以在线程初始化 / 创建成功后调用下面的函数接口让该线程进入就绪态： rt_err_t rt_thread_startup(rt_thread_t thread); 当调用这个函数时，将把线程的状态更改为就绪状态，并放到相应优先级队列中等待调度。如果新启动的线程优先级比当前线程优先级高，将立刻切换到这个线程。线程启动接口 rt_thread_startup() 的参数和返回值见下表： 参数 描述 thread 线程句柄 返回 —— RT_EOK 线程启动成功 -RT_ERROR 线程启动失败 4.3.3、静态线程rt_thread_t th1_ptr = NULL; //结构体变量接收返回值 struct rt_thread th2; rt_uint8_t th_2_stack[512] = {0}; void th1_entry(void *parameter) { while(1){ rt_kprintf(\"th1_entry running...\\n\"); rt_thread_mdelay(1000); } } void th2_entry(void *parameter) { int i = 0; for (i = 0; i &lt; 10; i++) { rt_kprintf(\"th2_entry running...\\n\"); // rt_thread_mdelay(1000); } } int main(void) { int ret = 0; //动态线程创建-&gt;函数名称、入口函数、给线程入口函数传参、线程栈的大小、优先级、系统滴答时间 th1_ptr = rt_thread_create(\"th1_demo\",th1_entry,NULL,1024,20,5); if (th1_ptr == RT_NULL) { LOG_E(\"rt_thread_create failed...\\n\"); return RT_ENOMEM; } LOG_D(\"rt_thread_create succeed...\\n\"); rt_thread_startup(th1_ptr); //静态线程初始化-&gt;线程对象、函数名称、入口函数、入口函数参数、线程栈起始地址、线程栈大小、优先级、系统滴答时间 ret = rt_thread_init(&amp;th2, \"th2_demo\", th2_entry , NULL, th_2_stack, sizeof(th_2_stack), 19, 5); if (ret &lt; 0) { LOG_E(\"rt_thread_init failed...\\n\"); return ret; } LOG_D(\"rt_thread_init succeed...\\n\"); rt_thread_startup(&amp;th2); } \\ | / - RT - Thread Operating System / | \\ 4.0.3 build Oct 28 2021 2006 - 2020 Copyright by rt-thread team \u001b[0m[D/main] rt_thread_create succeed... \u001b[0m \u001b[0m[D/main] rt_thread_init succeed... \u001b[0m th2_entry running... th2_entry running... th2_entry running... th2_entry running... th2_entry running... th2_entry running... th2_entry running... th2_entry running... th2_entry running... th2_entry running... msh &gt;th1_entry running... th1_entry running... th1_entry running... th1_entry running... th1_entry running... th1_entry running... th1_entry running... th1_entry running... th1_entry running... th1_entry running... th1_entry running... th1_entry running... th1_entry running... th1_entry running... th1_entry running... th1_entry running... th1_entry running... 注释th2_entry中的延时，则由于静态初始化的优先级更高会先打印十次，后面全部只会打印动态线程 静态线程的线程句柄（或者说线程控制块指针）、线程栈由用户提供。静态线程是指线程控制块、线程运行栈一般都设置为全局变量，在编译时就被确定、被分配处理，内核不负责动态分配内存空间。需要注意的是，用户提供的栈首地址需做系统对齐（例如 ARM 上需要做 4 字节对齐）。线程初始化接口 rt_thread_init() 的参数和返回值见下表： 参数 描述 thread 线程句柄。线程句柄由用户提供出来，并指向对应的线程控制块内存地址 name 线程的名称；线程名称的最大长度由 rtconfig.h 中定义的 RT_NAME_MAX 宏指定，多余部分会被自动截掉 entry 线程入口函数 parameter 线程入口函数参数 stack_start 线程栈起始地址 stack_size 线程栈大小，单位是字节。在大多数系统中需要做栈空间地址对齐（例如 ARM 体系结构中需要向 4 字节地址对齐） priority 线程的优先级。优先级范围根据系统配置情况（rtconfig.h 中的 RT_THREAD_PRIORITY_MAX 宏定义），如果支持的是 256 级优先级，那么范围是从 0 ～ 255，数值越小优先级越高，0 代表最高优先级 tick 线程的时间片大小。时间片（tick）的单位是操作系统的时钟节拍。当系统中存在相同优先级线程时，这个参数指定线程一次调度能够运行的最大时间长度。这个时间片运行结束时，调度器自动选择下一个就绪态的同优先级线程进行运行 返回 —— RT_EOK 线程创建成功 -RT_ERROR 线程创建失败 对于用 rt_thread_init() 初始化的线程，使用 rt_thread_detach() 将使线程对象在线程队列和内核对象管理器中被脱离。线程脱离函数如下： rt_err_t rt_thread_detach (rt_thread_t thread); 线程脱离接口 rt_thread_detach() 的参数和返回值见下表： 参数 描述 thread 线程句柄，它应该是由 rt_thread_init 进行初始化的线程句柄。 返回 —— RT_EOK 线程脱离成功 -RT_ERROR 线程脱离失败 这个函数接口是和 rt_thread_delete() 函数相对应的， rt_thread_delete() 函数操作的对象是 rt_thread_create() 创建的句柄，而 rt_thread_detach() 函数操作的对象是使用 rt_thread_init() 函数初始化的线程控制块。同样，线程本身不应调用这个接口脱离线程本身。 空闲线程是一个线程状态永远为就绪态的线程，因此设置的钩子函数必须保证空闲线程在任何时刻都不会处于挂起状态，如rt_thread_delay()、rt_thread_take()等可能会导致线程挂起的函数都不能使用 4.3.4、钩子函数在整个系统的运行时，系统都处于线程运行、中断触发 - 响应中断、切换到其他线程，甚至是线程间的切换过程中，或者说系统的上下文切换是系统中最普遍的事件。有时用户可能会想知道在一个时刻发生了什么样的线程切换，可以通过调用下面的函数接口设置一个相应的钩子函数。在系统线程切换时，这个钩子函数将被调用： void rt_scheduler_sethook(void (*hook)(struct rt_thread* from, struct rt_thread* to));复制错误复制成功 设置调度器钩子函数的输入参数如下表所示： 函数参数 描述 hook 表示用户定义的钩子函数指针 钩子函数 hook() 的声明如下： void hook(struct rt_thread* from, struct rt_thread* to);复制错误复制成功 调度器钩子函数 hook() 的输入参数如下表所示： 函数参数 描述 from 表示系统所要切换出的线程控制块指针 to 表示系统所要切换到的线程控制块指针 注：请仔细编写你的钩子函数，稍有不慎将很可能导致整个系统运行不正常（在这个钩子函数中，基本上不允许调用系统 API，更不应该导致当前运行的上下文挂起）。 4.3.5、设置调度器hook函数rt_thread_t th1_ptr = NULL; //结构体变量接收返回值 struct rt_thread th2; rt_uint8_t th_2_stack[512] = {0}; void th1_entry(void *parameter) { int i = 0; for (i = 0; i &lt; 5; ++i) { rt_kprintf(\"th1_entry running...\\n\"); rt_thread_mdelay(1000); } } void th2_entry(void *parameter) { int i = 0; for (i = 0; i &lt; 5; i++) { rt_kprintf(\"th2_entry running...\\n\"); rt_thread_mdelay(1000); } } void scheduler_hook(struct rt_thread *from, struct rt_thread *to) { rt_kprintf(\"from:%s ---&gt; to:%s\\n\",from-&gt;name,to-&gt;name); } int main(void) { int ret = 0; rt_scheduler_sethook(scheduler_hook); //动态线程创建-&gt;函数名称、入口函数、给线程入口函数传参、线程栈的大小、优先级、系统滴答时间 th1_ptr = rt_thread_create(\"th1_demo\",th1_entry,NULL,1024,20,5); if (th1_ptr == RT_NULL) { LOG_E(\"rt_thread_create failed...\\n\"); return -RT_ENOMEM; } LOG_D(\"rt_thread_create succeed...\\n\"); rt_thread_startup(th1_ptr); //静态线程初始化-&gt;线程对象、函数名称、入口函数、入口函数参数、线程栈起始地址、线程栈大小、优先级、系统滴答时间 ret = rt_thread_init(&amp;th2, \"th2_demo\", th2_entry , NULL, th_2_stack, sizeof(th_2_stack), 19, 5); if (ret &lt; 0) { LOG_E(\"rt_thread_init failed...\\n\"); return ret; } LOG_D(\"rt_thread_init succeed...\\n\"); rt_thread_startup(&amp;th2); } \\ | / - RT - Thread Operating System / | \\ 4.0.3 build Oct 28 2021 2006 - 2020 Copyright by rt-thread team \u001b[0m[D/main] rt_thread_create succeed... \u001b[0m \u001b[0m[D/main] rt_thread_init succeed... \u001b[0m from:main ---&gt; to:th2_demo? th2_entry running... from:th2_demo? ---&gt; to:tshell msh &gt;from:tshell ---&gt; to:th1_demo\u0001 th1_entry running... from:th1_demo\u0001 ---&gt; to:tidle0 from:tidle0 ---&gt; to:th2_demo? th2_entry running... from:th2_demo? ---&gt; to:tidle0 from:tidle0 ---&gt; to:th1_demo\u0001 th1_entry running... from:th1_demo\u0001 ---&gt; to:tidle0 from:tidle0 ---&gt; to:th2_demo? th2_entry running... from:th2_demo? ---&gt; to:tidle0 from:tidle0 ---&gt; to:th1_demo\u0001 th1_entry running... from:th1_demo\u0001 ---&gt; to:tidle0 from:tidle0 ---&gt; to:th2_demo? th2_entry running... from:th2_demo? ---&gt; to:tidle0 from:tidle0 ---&gt; to:th1_demo\u0001 th1_entry running... from:th1_demo\u0001 ---&gt; to:tidle0 from:tidle0 ---&gt; to:th2_demo? th2_entry running... from:th2_demo? ---&gt; to:tidle0 from:tidle0 ---&gt; to:th1_demo\u0001 th1_entry running... from:th1_demo\u0001 ---&gt; to:tidle0 from:tidle0 ---&gt; to:th2_demo? from:th2_demo ---&gt; to:tidle0 from:tidle0 ---&gt; to:th1_demo\u0001 from:th1_demo\u0001 ---&gt; to:tidle0 五、时钟管理操作系统需要通过时间来规范其任务 5.1、时钟节拍时钟节拍的长度可以根据RT_TICK_PER_SECOND的定义来调整。rtconfig.h配置文件中定义 /* *频率是1000hz周期是1/1000ms *所以节拍是1ms */ #define RT_TICK_PER_SECOND 1000 系统滴答定时器中断处理函数（每1ms触发一次systick定时器中断） /** * This is the timer interrupt service routine. *这是定时器中断服务程序 */ void SysTick_Handler(void) { /* enter interrupt */ rt_interrupt_enter(); HAL_IncTick(); rt_tick_increase();//++rt_tick;全局变量自加，记录的是系统从启动到现在的时间节拍数 /* leave interrupt */ rt_interrupt_leave(); } 5.2、获取系统节拍5.2.1、获取系统计数函数/** * This function will return current tick from operating system startup * * @return current tick */ rt_tick_t rt_tick_get(void) { /* return the global tick */ return rt_tick; } int main(void) { int i = 0; rt_tick_t tick = 0; for (i = 0; i &lt; 10; ++i) { tick = rt_tick_get(); rt_kprintf(\"tick:%u\\n\",tick); rt_thread_mdelay(500);//休眠500ms } return RT_EOK; } 可以打印出时钟节拍 5.3、定时器定时器，是指从指定的时刻开始，经过一定的指定时间后触发一个事件，例如定个时间提醒第二天能够按时起床。定时器有硬件定时器和软件定时器之分： 1）硬件定时器是芯片本身提供的定时功能。一般是由外部晶振提供给芯片输入时钟，芯片向软件模块提供一组配置寄存器，接受控制输入，到达设定时间值后芯片中断控制器产生时钟中断。硬件定时器的精度一般很高，可以达到纳秒级别，并且是中断触发方式。 2）软件定时器是由操作系统提供的一类系统接口，它构建在硬件定时器基础之上，使系统能够提供不受数目限制的定时器服务。 RT-Thread 操作系统提供软件实现的定时器，以时钟节拍（OS Tick）的时间长度为单位，即定时数值必须是 OS Tick 的整数倍，例如一个 OS Tick 是 10ms，那么上层软件定时器只能是 10ms，20ms，100ms 等，而不能定时为 15ms。RT-Thread 的定时器也基于系统的节拍，提供了基于节拍整数倍的定时能力。 HSE：外部时钟","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://tqoqt.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"keil","slug":"keil","permalink":"https://tqoqt.github.io/tags/keil/"},{"name":"RT_Thread","slug":"RT-Thread","permalink":"https://tqoqt.github.io/tags/RT-Thread/"}],"author":"张君韵"},{"title":"keil等的开发环境","slug":"嵌入式开发环境","date":"2021-09-06T16:00:00.000Z","updated":"2021-09-21T13:49:54.284Z","comments":true,"path":"posts/keil1.html","link":"","permalink":"https://tqoqt.github.io/posts/keil1.html","excerpt":"","text":"前言 相信大部分人在设置开发环境时都会碰到很多问题。则写这个博客记录一些开发软件下载链接 IDM下载贼快 链接：https://pan.baidu.com/s/1uu5FGYhsk6frsCgq3HNKQg提取码：1234 按要求安装后，在浏览器安装插件，再安装一个IDM，可以下载巨快，安装其他插件也可无限制的下载百度网盘 Keil下载// -date: 2019-11-20// -time: 0:18 最新：MDK5.29版本https://armkeil.blob.core.windows.net/eval/MDK529.EXE// -date: 2019-06-10// -time: 0:1最新：MDK5.28A版本下载https://armkeil.blob.core.windows.net/eval/MDK528.EXE// -date: 2019-1-11// -time: 0:18最新：MDK5.27Pre版本下载https://armkeil.blob.core.windows.net/eval/MDK527pre.EXE// -date: 2018-09-11// -time: 0:18 最新：MDK5.26版本下载https://armkeil.blob.core.windows.net/eval/MDK526.EXE STM32CubeMXSTM32CubeMX - STM32Cube初始化代码生成器 - STMicroelectronics 画板工具立创ＥＤＡhttps://image.lceda.cn/files/lceda-windows-x64-6.4.23.exe 嘉立创打板工具https://download.jlc.com/jlchelper/release/3.4.4/JLCPcAssit_setup_3.4.4.zip ＰｉｃＧｏhttps://github-releases.githubusercontent.com/113965016/c12415ff-1328-4668-b8b1-df91177cb077?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20210907%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20210907T145427Z&amp;X-Amz-Expires=300&amp;X-Amz-Signature=0bbfca0b314cbe6fc1b8fd71e73181b9d47774c7131bfe2419c2d9803192aa83&amp;X-Amz-SignedHeaders=host&amp;actor_id=84925708&amp;key_id=0&amp;repo_id=113965016&amp;response-content-disposition=attachment%3B%20filename%3DPicGo-Setup-2.3.0-beta.8-x64.exe&amp;response-content-type=application%2Foctet-stream ＶＳＣｏｄｅhttps://az764295.vo.msecnd.net/stable/e7d7e9a9348e6a8cc8c03f877d39cb72e5dfb1ff/VSCodeUserSetup-x64-1.60.0.exe 万兴PDF破解版可免费转换各种文件链接：https://pan.baidu.com/s/1DeuXZabHEa2fzO5uViJ_xg提取码：1234 Ｏｆｆｉｃ破解版，可安装任意的文件链接：https://pan.baidu.com/s/1_JbUy3teCUDlwC5iRgWwsw提取码：1234 STM开发问题突然不能下载程序 swd/jtag communication failure 发现这个问题 则 将板子供电全部断开，这里包括3.3V电源供电和JLINK等所有能给开发板供上电的设备全断开2，找到BOOT0引脚，将BOOT0拉高。 方法：在板子上找一个高电平引脚，手动用导线将BOOT0连接到该引脚上即可。 注意：我的STM32板子供电是3.3V的，所以我找了一个3.3V的引脚，用导线连接到了BOOT0上，千万别弄错了，电平接高了不小心可是要烧坏板子的！3，BOOT0拉高以后，保持这个姿势不要动，打开电源，重新给板子上电4，插上JLink或者STLink ，下载程序。 一般这次肯定可以下载进去了。下载完成以后，就可以断开BOOT0了，让他恢复低电平。好到这里就全部完成了，板子肯定也回复正常了，继续嗨吧。 上述方法原因解释开板默认JTAG和SWD接口都是打开的，BOOT0是低电平，当把BOOT0置高时，给板子上电，板子启动的时候程序会卡住，也就是内部闪光的程序并未执行，这个时候SW和JTAD接口都是出于默认打开的状态。然后下载一个不关闭JTAG或者SW接口的程序，覆盖之前闪存中的程序就好了。 所以先将板子供电全部断开（这里包括3.3V电源供电和JLINK等所有能给开发板供上电的设备全断开），再将开发板的BOOT0拉高，重新给开发板上电，把程序中关闭JTAG或者SW的程序删掉，然后下载到开发板中，程序下载完成就好了。 SWD和JTAG被关闭原因正搞板子发现程序下载不进去了，到处查找原因，发现自己在程序中不小心把STM32的SWD和JTAD接口都给关了，如下就是关掉这两个接口的两句程序：","categories":[{"name":"开发环境篇","slug":"开发环境篇","permalink":"https://tqoqt.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%AF%87/"}],"tags":[{"name":"STM32CubeMX","slug":"STM32CubeMX","permalink":"https://tqoqt.github.io/tags/STM32CubeMX/"},{"name":"keil","slug":"keil","permalink":"https://tqoqt.github.io/tags/keil/"}],"author":"张君韵"},{"title":"Git使用","slug":"Git","date":"2021-09-06T16:00:00.000Z","updated":"2021-09-10T16:07:14.128Z","comments":true,"path":"posts/git.html","link":"","permalink":"https://tqoqt.github.io/posts/git.html","excerpt":"","text":"Gitgit简介Git有三大区（工作-Untracked、暂存-Unstaged、版本-Uncommited） 1.版本控制本地版本控制个人使用本地存储 集中版本控制存储到服务器中，使用完上传到服务器中，需要时从服务器下载，有服务器奔溃风险 分布式版本控制每个人拥有全部代码，可以存储在本地，有网时上传到服务器中 2.git和SVN的区别SVN是集中式版本控制系统，版本库集中放在服务器中，工作时从服务器更新到最新版本，完成工作后上传到服务器中，必须联网，对网络带宽要求高 git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作时不需联网，协同时，两人互相把修改的部分推送给对方，就可以看到对方的修改。可以看到对方修改了那些代码和文件 3.git命令1.cd .. 回到文件上一级 2.cd xx 到xx文件夹中 3.pwd 显示当前目录 4.clear 清屏 5、ls 列出当前文件夹中的文件 6、touch index.js 新建一个index.js文件 7、rm index.js 移除一个index.js文件 8、mkdir test 新建一个test文件夹 9、rm -r test 删除掉test文件夹 10、mv index.html test 把index.html文件移动到test文件夹中（在命令行中的文件） 11、reset 重新初始化终端/清屏 12、history 查看命令历史 13、help 帮助 14、exit 退出 15、# 注释 4、Git配置1、git config –global –list 查看配置的用户名和邮箱 2、git config –global user.name “xx” 设置用户名 3、gitconfig –global user.email “xx” 设置用户邮箱 5、工作原理 git本地有三个工作区，工作目录（working Directory)、暂存区（Stage/index）、资源库（Repository或git Directiory），加上远程的git仓库（Remote Directory） ​ git push（上传到服务） Remote Directory（远程仓库） git commit（提交修改） History（本地git仓库） git pull（从服务器下拉代码） git add files（添加文件） Stage（index）（暂存区） git reset（上一个版本） Working Directory（本地文件） git checkout（切换本地分支） ​ ​ ​ ​ git clone 网址，克隆网址东西 6、git文件操作 7、git的基本操作1、git add . 添加所有文件提交到暂存区 2、git status 查看所有文件的状态 3、git commit -m “new file hello.txt” 提交暂存区的文件到本地仓库 -m “xx”提交信息 4、忽略文件 ​ #.txt #忽略所有的.txt文件，.txt结尾的文件不会上传 ​ ！lib.txt #但lib.txt文件除外 ​ /temp #仅忽略项目根目录下的TODO文件，不包括其他目录temp ​ build/ #忽略build/目录下的所有文件 （/在前面往上忽略，在后面往下忽略） ​ doc/*.txt #会忽略doc/notes.txt,但不包括doc/server/arch.txt 8、个人操作 git init 初始化仓库 git clone 网址 克隆网址上的仓库代码 无法克隆时去控制面板的凭据管理器的Windows凭据中找到其用户名和密码修改 git config –global –list 查看配置的用户名和邮箱 git config –global user.name “xx” 设置用户名 gitconfig –global user.email “xx” 设置用户邮箱 CD xx 进入克隆下来的文件中 touch test.txt 新建test.txt文件 rm test.txt 移除一个test.txt文件 mkdir test 新建一个test文件夹 rm -r test 删除掉test文件夹 git add test.txt 添加test.txt文件到暂存区 mv index.html test 把index.html文件移动到test文件夹中（在命令行中的文件） reset 重新初始化终端/清屏 history 查看命令历史 git commit -m “new test.txt” 多次git add后，提交形成记录，“new test.txt”为提交日志 git status 查看未提交的文件 git branch -a 查看所有分支，本地及远程分支 git checkout -b xxx 以当前分支为基础新建立本地分支xxx git checkout -b xxx origin/xxx 以远程分支xxx为基础新建立本地分支xxx，本地分支名和远程分支名一致，不然推送不到远程服务器 git checkout xxx 切换到本地其他分支，切换前要提交当前分支点改动 git branch -D xxx 强制删除本地分支 git push origin –delete xxx 删除远程服务器分支 git pull origin xxx 从服务器分支更新代码到本地 git push origin xxx 将数据上推到服务器分支中，上推前先将本地代码更新到最新版本 git tag xx 建立本地标签 git tag 查看本地所有标签 git push origin –tags 把本地的所有文档推送到远程服务器 git fetch 从远程服务器更新代码到本地，但不自动合并，执行后可以更新分支和tag git merge xxx 把本地分支xxx合并到当前分支 echo “xxxxx” &gt;test.txt 在test.txt文件中写入数据xxxx 修改git branch -a中显示出了的head指向-git remote set-head origin feature可将head指向feature 列出本地所有分支：命令：git branch 创建一个新分支：命令：git branch 分支名称 删除指定本地分支：命令：git branch -d 删除的分支名称 -D为强制删除，-d为正常操作情况下的删除。 命令大全ls -a 查看目录中的文件夹（蓝色）和文件（白色） git add &lt;文件名&gt; 将文件提交到暂存区 git branch -a 查看本地及远程分支 git branch -l 查看本地分支 git branch -r 查看远程所有分支 git checkout -b dev 建立一个新的本地分支dev git checkout dev 切换到本地dev git checkout -d master dev 删除本地库dev git checkout –track origin/dev 切换到远程dev分支 git clone 网址 克隆网址上的仓库代码 无法克隆时去控制面板的凭据管理器的Windows凭据中找到其用户名和密码修改 git commit -m “提交信息” 将暂存区的文件提交到本地仓库 git diff branchname filepath 当前分支的文件与branchname分支的文件进行比较 git diff commitld filepath 与某次提交进行比较 git diff filepath 工作区与暂存区比较 git diff HEAD filepath 工作区与HEAD（当前工作分支）比较 git fetch 从远程获取最新版本到本地不会自动merge git log 查看git commit的日志，推出git log按下q即可 git ls-files 显示出暂存区和工作区内的文件 git merge origin/dev 将分支dev和当前分支合并g’i’tte’ch git pull 本地与服务器端同步 git push origin master 将本地分支推送到服务器master分支上 gti rm –cache 文件名 仅仅删除暂存区里的文件 git rm -f 文件名 删除暂存区和工作区的文件 git reset –soft 版本库ID 撤销已提交的版本库，不会修改暂存区和工作区 git reset –mixed 版本库ID 撤销已提交的版本库和暂存区不会修改工作区 git reset hard 版本库ID 彻底将工作区、暂存区和版本库记录恢复到指定的版本库 git status 查看当前状态","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://tqoqt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://tqoqt.github.io/tags/Git/"}],"author":"张君韵"},{"title":"四线模拟IIC点亮屏幕","slug":"四线模拟IIC","date":"2021-09-01T16:00:00.000Z","updated":"2021-09-10T16:07:33.829Z","comments":true,"path":"posts/stm32001.html","link":"","permalink":"https://tqoqt.github.io/posts/stm32001.html","excerpt":"","text":"前言主要是运用stm32F103RBT6 中的模拟IIC点亮四线的OLED屏 先不写上链接 链接：https://pan.baidu.com/s/1ebrh6OHc7GkQpjKQb7PRlg提取码：1234 测试一下PicGo图床","categories":[{"name":"学习篇","slug":"学习篇","permalink":"https://tqoqt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"https://tqoqt.github.io/tags/STM32/"},{"name":"STM32CubeMX","slug":"STM32CubeMX","permalink":"https://tqoqt.github.io/tags/STM32CubeMX/"}],"author":"张君韵"},{"title":"Hexo之渲染绕过","slug":"Hexo-xr","date":"2020-04-27T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"posts/17fd92ae.html","link":"","permalink":"https://tqoqt.github.io/posts/17fd92ae.html","excerpt":"","text":"0x001 Hexo 渲染 在Hexo部署时会默认渲染source下的所有html页面，但有时候想在Hexo博客上单独自定义html页面或README.md时，却不希望被Hexo渲染。因此对某个文件或者目录进行排除渲染是非常必要的。 0x002 方法一：font matterHexo新建网站页面，然后将你的代码直接写入 index.md 中 在 Front matter 中添加 layout: false，此方法适用于单一的纯HTMLCSS 页面。 --- title: tools date: 2020-04-28 00:00:00 type: \"tools\" layout: false --- 0x003 方法二：skip render在博客根目录下的 _config.yml，找到 skip_render，大概在32行左右，写入你想要的跳过渲染的路径，注意缩进和空格。 # 指定目录跳过hexo渲染 skip_render: - 'tools/*' - 'tools/**' 注释：tools/* 表示在目录 source/fireworks 下的文件全部跳过渲染，tools/** 表示在博客根目录 source/tools/ 文件夹下的文件全部跳过渲染（例如页面的 js、css 在另一个文件夹中）。 0x004 案例：webstack 导航webstack是一个纯静态的网址导航网站，内容均由viggo收集并整理。项目基于bootstrap前端框架开发。 Github：https://github.com/WebStackPage/WebStackPage.github.io 在博客根目录 source/下新建tools，然后新建index.html,将webstack网页源码全选复制粘贴到里面。 本站的webstack源码：view-source:http://luckyzmj.cn/tools/ 注意：将源码里的部分信息以及跳转链接按照你真实个人博客的环境进行修改。 然后打开博客根目录下配置文件_config.yml，找到skip_render，做如下修改： skip_render: - 'tools/*' - 'tools/**' 最后执行hexo clean和hexo s -g 本地预览，检查无误后hexo g -d部署到服务器上即可。 参考文章 https://xiabor.com/2020/04/21/hexo3/#%E5%A6%82%E4%BD%95%E8%B7%B3%E8%BF%87hexo%E7%9A%84%E6%B8%B2%E6%9F%93","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://tqoqt.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://tqoqt.github.io/tags/Hexo/"},{"name":"渲染绕过","slug":"渲染绕过","permalink":"https://tqoqt.github.io/tags/%E6%B8%B2%E6%9F%93%E7%BB%95%E8%BF%87/"}],"author":"Luckey"},{"title":"PicGo+GitHub 图床搭建","slug":"PicGo-GitHub","date":"2020-03-14T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"posts/7a46f93c.html","link":"","permalink":"https://tqoqt.github.io/posts/7a46f93c.html","excerpt":"","text":"前言用GitHub搭建图床，在很久之前我就有了解，但由于市面上有挺多免费的图床，比如我之前一直在用的 路过图床，所以一直懒得动手搭建GitHub图床。一直到前两天我在完善博客的相册时，发现 路过图床 免费版的有这么多限制，比如：每小时限制上传50张图片，每天限制上传100张图片，而且免费版用户的存储容量貌似不过300M，这才意识到有一个自己的GitHub图床是多么重要。 0x001 PicGO 介绍PicGo是一款图片上传工具，目前支持 SM.MS图床、腾讯云COS、GitHub图床、七牛图床、Imgur图床、阿里云OSS、又拍云图床，未来将支持更多图床。 在支持的这些图床中，SM.MS和Imgur有免费版和收费版，免费版的肯定有很多的使用限制，比如每小时限制上传次数，限制用户的上传容量等等；腾讯云COS、阿里云、有拍云都是要收费使用的；七牛云貌似前期使用免费，后期又要收费才能使用，就剩下的GitHub才是免费且最可靠的。 PicGo源项目GitHub地址已给出，但是去GitHub下载速度非常慢，这里额外提供一个蓝奏云的快速下载地址。 GitHub地址：https://github.com/Molunerfinn/PicGo 蓝奏云地址：https://luckyzmj.lanzous.com/id3e0id 0x002 GitHub 图床1. 创建GitHub图床仓库首先需要有一个登录GitHub的账号，没有的话去GitHub官网注册一个 创建一个新的图床仓库，点击右上角的New repository 填写如下配置信息，然后Create创建仓库 2. 获取GitHub token值点击右上的头像，选择设置Setting 点击选择Developer settings 点击 Generate New token 填写如下配置信息，只要勾选repo选项即可，然后页面拉到底部点击Generate token 即可 此时会跳转到带有token的页面，将token值复制记录下来，之后用PicGo绑定GitHub图床时会利用到 0x003 PicGo 配置1. 绑定GitHub图床首先下载安装好PicGo软件，然后在右列表找到GitHub图床配置 1. 设定仓库名(必填)： 按照“GitHub账户名/仓库名的格式填写”，比如我的是：Luckyzmj/imgbed 2. 设定分支名(必填)： 仓库分支名填写”master”或者”main”，视情况而定。因为GitHub 官方表示,从2020年10月1日起,在该平台上创建的所有新的源代码仓库将默认被命名为”main”,而不是原先的”master”。 3. 设定Token(必填)： 将之前步骤的Token值复制粘贴到这里 4. 指定存储路径： 这个选项可以为空，如果想将图片上传到仓库的指定目录下，可以填写目录名加/，比如我的imgbed仓库下有个posts文件夹，需设置为 posts/ 5. 设定自定义域名： 这里统一用jsdelivr的CDN加速域名，在上传图片后成功后，PicGo会将“自定义域名+上传的图片名”生成的访问链接 自定义域名格式：https://cdn.jsdelivr.net/gh/GitHub账户名/仓库名 以我的格式为例：https://cdn.jsdelivr.net/gh/Luckyzmj/imgbed 配置完全部信息后，点击 设为默认图床，最后点击确定即可 2. 上传图片到图床在上传区上传图片，可支持本地图片上传(可多选图片)、剪贴板上传、URL上传等三种方式。上传图片成功后，选择你想要生成的图片链接格式 在图片区，可以看到成功上传的图片，选择相应的图片进行操作即可 3. PicGo 注意事项如果配置完PicGo后却上传图片失败，可以参考以下方法： 检查自定义域名是否正确 仓库名不要有空格 图片名字不要带有特殊符号，如：%、+、*、空格等 建议开启时间戳重命名，防止图片名字重复 上传图片间歇太短，需在PicGo设置中关闭Server选项 PicGo应用不稳定因素，需重启应用 参考文章 https://blog.csdn.net/sunhwee/article/details/100109956","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://tqoqt.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"https://tqoqt.github.io/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"https://tqoqt.github.io/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"Luckey"},{"title":"阿里云服务器部署Hexo博客","slug":"blog-aliyun","date":"2020-02-26T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"posts/19d2a4e6.html","link":"","permalink":"https://tqoqt.github.io/posts/19d2a4e6.html","excerpt":"","text":"前言 相信大部分人使用Hexo搭建个人博客都会部署到一些免费的代码托管平台上，但这些免费的平台总是差强人意，比如国外的GitHub平台虽然完全免费，但在国内访问加载速度非常慢，又或者是国内的码云平台免费版有许多功能被阉割掉了，比如不能自定义域名，不能每次自动刷新提交的代码，需要到码云平台上手动刷新，如此一来非常繁琐。 为了有效解决上诉的一些问题，有条件的话，不妨在自己的云服务器上搭建Hexo博客。 效果演示 这是Hexo博客部署到GitHub上的网站测速效果 这是Hexo博客部署到阿里云服务器后的网站测速效果 环境准备 本地环境：Windows 10 云服务器环境：阿里云ECS（CentOS7.x） 开始部署 本地环境搭建1.安装Git 到git官网上下载.exe文件,Download git,安装选项还是全部默认，最后一步添加路径时选择Use Git from the Windows Command Prompt。 Git下载地址 Git教程 2.安装Nodejs 到Node.js官网下载.exe文件，安装选项全部默认。安装好之后，按Win+R打开cmd命令提示符，输入node -v和npm -v，若出现版本号，则说明安装成功。 使用npm阿里的国内镜像进行加速下载 npm config set registry https://registry.npm.taobao.org 4.安装Hexo 先创建一个文件夹MyBlog，用来存放自己的博客文件，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash here打开）。 定位到该目录下，输入npm install -g hexo-cli安装Hexo。可能会有几个报错，不用理会。 npm install -g hexo-cli 安装完后输入hexo -v,若出现版本号则，说明安装成功。 接下来初始化一下hexo,即初始化我们的博客，输入hexo init初始化文件夹 hexo init MyBlog 新建完成后，指定文件夹MyBlog目录下有： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题** _config.yml: 博客的配置文件** 输入hexo g生成静态网页，然后输入hexo s打开本地服务器预览 hexo g hexo s 生成ssh公钥在本地桌面点击右键Git Bash Here打开Git终端，执行如下命令`,一路回车 ssh-keygen -t rsa 这个时候它会告诉你已经生成了.ssh的文件夹。在git bash中输入 cat ~/.ssh/id_rsa.pub 输出的内容就是公钥信息了 阿里云服务器环境搭建安装Git yum install git 创建Git账户 adduser git 添加账户权限 chmod 740 /etc/sudoers vim /etc/sudoers 找到 ## Allow root to run any commands anywhere root ALL=(ALL) ALL 添加以下内容 git ALL=(ALL) ALL 保存退出并改回权限 chmod 400 /etc/sudoers 设置git账户密码 sudo passwd git 切换至git用户，创建 ~/.ssh 文件夹和 ~/.ssh/authorized_keys 文件，并赋予相应的权限 su git mkdir ~/.ssh vim ~/.ssh/authorized_keys # 然后将win10中生成的id_rsa.pub文件中的公钥复制到authorized_keys chmod 600 /home/git/.ssh/authorized_keys chmod 700 /home/git/.ssh 在本地Git终端中测试是否能免密登录git，其中SERVER为填写自己的云主机IP，执行输入yes后不用密码就说明好了 ssh -v git@SERVER 创建目录 #repo作为为Git仓库目录 mkdir /var/repo chown -R git:git /var/repo chmod -R 755 /var/repo #hexo作为网站根目录 mkdir /var/www/hexo chown -R git:git /var/www/hexo chmod -R 755 /var/www/hexo 然后创建一个裸的 Git 仓库 cd var/repo git init --bare hexoBlog.git 创建一个新的 Git 钩子，用于自动部署 在 /var/repo/hexoBlog.git 下，有一个自动生成的 hooks 文件夹。我们需要在里边新建一个新的钩子文件 post-receive。 vim /var/repo/hexoBlog.git/hooks/post-receive 按 i 键进入文件的编辑模式，在该文件中添加两行代码（将下边的代码粘贴进去)，指定 Git 的工作树（源代码）和 Git 目录（配置文件等） #!/bin/bash git --work-tree=/var/www/hexo --git-dir=/var/repo/hexoBlog.git checkout -f 然后，按 Esc 键退出编辑模式，输入”:wq” 保存退出。 修改文件权限，使得其可执行 chown -R git:git /var/repo/hexoBlog.git/hooks/post-receive chmod +x /var/repo/hexoBlog.git/hooks/post-receive 到此为止 Git 仓库就搭建完成了。 阿里云服务器配置Nginx用宝塔面板来一键部署Nginx Linux面板6.0安装命令(暂时仅兼容Centos7.x，其它系统版本请安装5.9稳定版)： yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; bash install.sh Linux面板6.0升级专业版 curl http://download.bt.cn/install/update6.sh|bash 安装完成后会显示面板后台地址·账号·密码。打开面板后台地址登陆面板，选择Nginx的部署方案，静静等待部署。 部署完成，点击网站-添加站点-输入域名(没有域名的输入自己的IP地址)-底部的PHP版本选择”纯静态”-提交。 网站创建完成后点击设置-配置文件 server { listen 80; # server_name 填写自己的域名 server_name luckyzmj.cn blog.luckyzmj.cn; index index.php index.html index.htm default.php default.htm default.html; # 这里root填写自己的网站根目录，修改为/var/www/hexo root /var/www/hexo; -保存 点击设置-网站目录，修改为/var/www/hexo ，保存 重启宝塔面板服务 service bt restart 本地Hexo部署到阿里云服务器进入到本地Hexo博客的文件夹MyBlog,右键点击Git Bash Here，输入命令 #定义邮箱(更换为你的邮箱地址就行) git config --global user.email \"you@example.com\" #定义名称(更换自定义一个名称就行) git config --global user.name \"Your Name\" 配置_config.yml,完成自动化部署 打开本地Hexo博客的文件夹MyBlog文件夹下的_config.yml, 找到deploy deploy: type: git #server改为你的服务IP地址或解析后的域名 #例如我改为repo: git@luckyzmj.cn:/var/repo/blog.git repo: git@server:/var/repo/blog.git branch: master 保存后，即可测试部署 再进入到本地Hexo博客的文件夹MyBlog,右键点击Git Bash Here，输入命令 hexo clean hexo g -d 不报错说明完成，打开浏览器输入你的域名或ip地址就可以看到你部署的Hexo博客了。 到此为止，我们已经成功部完成，并且访问自己的服务器端比访问Github快多了。 小贴士 在部署过程中，执行 hexo d发现部署老是出错，什么权限不允许之类的，这里我们需要检查我们在上述的git操作部署是否使用了git用户操作，若是没有，需要给相应的目录更改用户组 使用 chown -R git:git /var/repo/ 这条命令递归的将repo目录及其子目录用户组设置为git。 同时使用 chown -R git:git /var/www/hexo 这样即可解决此类问题。 还有一个问题就是绑定域名后不能访问。原因是在国内任何域名只要绑定到国内的服务器主机上都必须去工信部和公安部备案完后才能正常使用。如果是港澳台的服务器或者是国外的服务器则可以不需要备案。 参考文章 https://blog.csdn.net/weixin_33907511/article/details/91398208?utm_source=distribute.pc_relevant.none-task","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://tqoqt.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://tqoqt.github.io/tags/Hexo/"},{"name":"阿里云","slug":"阿里云","permalink":"https://tqoqt.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"博客","slug":"博客","permalink":"https://tqoqt.github.io/tags/%E5%8D%9A%E5%AE%A2/"}],"author":"Luckey"}],"categories":[{"name":"技巧篇","slug":"技巧篇","permalink":"https://tqoqt.github.io/categories/%E6%8A%80%E5%B7%A7%E7%AF%87/"},{"name":"学习篇","slug":"学习篇","permalink":"https://tqoqt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"},{"name":"软件篇","slug":"软件篇","permalink":"https://tqoqt.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%AF%87/"},{"name":"工具","slug":"工具","permalink":"https://tqoqt.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"开发语言","slug":"开发语言","permalink":"https://tqoqt.github.io/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"},{"name":"操作系统","slug":"操作系统","permalink":"https://tqoqt.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"开发环境篇","slug":"开发环境篇","permalink":"https://tqoqt.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%AF%87/"},{"name":"博客篇","slug":"博客篇","permalink":"https://tqoqt.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://tqoqt.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"C语言指针","slug":"C语言指针","permalink":"https://tqoqt.github.io/tags/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/"},{"name":"Office","slug":"Office","permalink":"https://tqoqt.github.io/tags/Office/"},{"name":"破解","slug":"破解","permalink":"https://tqoqt.github.io/tags/%E7%A0%B4%E8%A7%A3/"},{"name":"keil","slug":"keil","permalink":"https://tqoqt.github.io/tags/keil/"},{"name":"Arduino","slug":"Arduino","permalink":"https://tqoqt.github.io/tags/Arduino/"},{"name":"ESP32","slug":"ESP32","permalink":"https://tqoqt.github.io/tags/ESP32/"},{"name":"RT_Thread","slug":"RT-Thread","permalink":"https://tqoqt.github.io/tags/RT-Thread/"},{"name":"代码规范","slug":"代码规范","permalink":"https://tqoqt.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"GitHub","slug":"GitHub","permalink":"https://tqoqt.github.io/tags/GitHub/"},{"name":"STM32CubeMX","slug":"STM32CubeMX","permalink":"https://tqoqt.github.io/tags/STM32CubeMX/"},{"name":"Git","slug":"Git","permalink":"https://tqoqt.github.io/tags/Git/"},{"name":"STM32","slug":"STM32","permalink":"https://tqoqt.github.io/tags/STM32/"},{"name":"Hexo","slug":"Hexo","permalink":"https://tqoqt.github.io/tags/Hexo/"},{"name":"渲染绕过","slug":"渲染绕过","permalink":"https://tqoqt.github.io/tags/%E6%B8%B2%E6%9F%93%E7%BB%95%E8%BF%87/"},{"name":"PicGo","slug":"PicGo","permalink":"https://tqoqt.github.io/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"https://tqoqt.github.io/tags/GitHub%E5%9B%BE%E5%BA%8A/"},{"name":"阿里云","slug":"阿里云","permalink":"https://tqoqt.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"博客","slug":"博客","permalink":"https://tqoqt.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]}