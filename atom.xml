<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张君韵</title>
  
  <subtitle>张君韵の博客</subtitle>
  <link href="https://tqoqt.github.io/atom.xml" rel="self"/>
  
  <link href="https://tqoqt.github.io/"/>
  <updated>2021-12-14T16:16:22.922Z</updated>
  <id>https://tqoqt.github.io/</id>
  
  <author>
    <name>张君韵</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>工具备注</title>
    <link href="https://tqoqt.github.io/posts/office.html"/>
    <id>https://tqoqt.github.io/posts/office.html</id>
    <published>2021-12-14T15:17:00.000Z</published>
    <updated>2021-12-14T16:16:22.922Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="选择部署"><a href="#选择部署" class="headerlink" title="选择部署"></a>选择部署</h1><p><img src="https://cdn.jsdelivr.net/gh/TQOQT/picgobed/img/202112142323607.png" alt="image-20211214232302084"></p><p>我选择365应用企业版，看个人需要，应用程序按需求选取，体系结构选取32位，其他不用变化</p><h1 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h1><p><img src="https://cdn.jsdelivr.net/gh/TQOQT/picgobed/img/202112142324000.png" alt="image-20211214232400796"></p><p>选择是开始部署</p><h1 id="部署完点进查看"><a href="#部署完点进查看" class="headerlink" title="部署完点进查看"></a>部署完点进查看</h1><p><img src="https://cdn.jsdelivr.net/gh/TQOQT/picgobed/img/202112150012542.png" alt="image-20211215001143374"></p><h1 id="使用其他账户创建新账户"><a href="#使用其他账户创建新账户" class="headerlink" title="使用其他账户创建新账户"></a>使用其他账户创建新账户</h1><p><strong>按要求填写到账户登入到账户未激活</strong></p><h1 id="先选择清楚所有许可证"><a href="#先选择清楚所有许可证" class="headerlink" title="先选择清楚所有许可证"></a>先选择清楚所有许可证</h1><p><img src="https://cdn.jsdelivr.net/gh/TQOQT/picgobed/img/202112150010702.png" alt="image-20211215001034701"></p><h1 id="清除完后点击安装许可证到"><a href="#清除完后点击安装许可证到" class="headerlink" title="清除完后点击安装许可证到"></a>清除完后点击安装许可证到</h1><p><img src="https://cdn.jsdelivr.net/gh/TQOQT/picgobed/img/202112150012787.png" alt="image-20211215001252021"></p><p>到出现产品密钥安装成功</p><h1 id="点击右上角激活"><a href="#点击右上角激活" class="headerlink" title="点击右上角激活"></a>点击右上角激活</h1><p><img src="https://cdn.jsdelivr.net/gh/TQOQT/picgobed/img/202112150014181.png" alt="image-20211215001428121"></p><h1 id="出现下列情况"><a href="#出现下列情况" class="headerlink" title="出现下列情况"></a>出现下列情况</h1><p><img src="https://cdn.jsdelivr.net/gh/TQOQT/picgobed/img/202112150015325.png" alt="image-20211215001536681"></p><p>重复清除许可证、安装许可证、激活操作</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="工具" scheme="https://tqoqt.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Office" scheme="https://tqoqt.github.io/tags/Office/"/>
    
    <category term="破解" scheme="https://tqoqt.github.io/tags/%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://tqoqt.github.io/posts/c-c.html"/>
    <id>https://tqoqt.github.io/posts/c-c.html</id>
    <published>2021-12-09T16:35:01.554Z</published>
    <updated>2021-12-09T16:38:43.136Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="总体原则"><a href="#总体原则" class="headerlink" title="总体原则:"></a>总体原则:</h1><h2 id="1-清晰第一"><a href="#1-清晰第一" class="headerlink" title="1)清晰第一:"></a>1)清晰第一:</h2><p>​    见名知意，有完整的功能注释及用法。</p><h2 id="2-简洁为美"><a href="#2-简洁为美" class="headerlink" title="2)简洁为美:"></a>2)简洁为美:</h2><p>​    一个函数-一个功能，尽量在50行代码完成-一个逻辑。</p><h2 id="3-风格统一"><a href="#3-风格统一" class="headerlink" title="3)风格统一:"></a>3)风格统一:</h2><p>选择合适的风格，保存代码风格统- 。</p><h2 id="1、头文件"><a href="#1、头文件" class="headerlink" title="1、头文件"></a>1、头文件</h2><h3 id="原则1-1头文件中适合放置接口的声明，不适合放置实现。"><a href="#原则1-1头文件中适合放置接口的声明，不适合放置实现。" class="headerlink" title="原则1.1头文件中适合放置接口的声明，不适合放置实现。"></a>原则1.1头文件中适合放置接口的声明，不适合放置实现。</h3><p>说明:头文件是模块(Module)或单元(Unit)的对外接口。头文件中应放置对外部的声明，如对外提供的函数声明、宏定义、类型定义等。</p><h3 id="原则1-2头文件应当职责单一"><a href="#原则1-2头文件应当职责单一" class="headerlink" title="原则1.2头文件应当职责单一"></a>原则1.2头文件应当职责单一</h3><p>说明:头文件过于复杂，依赖过于复杂是导致编译时间过长的主要原因。很多现有代码中头文件过大，职责过多，再加上循环依赖的问题，可能导致为了在.c中使用一个宏，而包含十几个头文件。</p><h3 id="原则1-3头文件应向稳定的方向包含"><a href="#原则1-3头文件应向稳定的方向包含" class="headerlink" title="原则1.3头文件应向稳定的方向包含"></a>原则1.3头文件应向稳定的方向包含</h3><p>说明:头文件的包含关系是一种依赖，一 般来说， 应当让不稳定的模块依赖稳定的模块，从而当不稳定的模块发生变化时，不会影响(编译)稳定的模块。</p><p>产品依赖于平台，平台依赖于标准库。</p><p>除了不稳定的模块依赖于稳定的模块外，更好的方式是两个模块共同依赖于接口。</p><h3 id="规则1-1编写-C-和-H"><a href="#规则1-1编写-C-和-H" class="headerlink" title="规则1.1编写.C 和.H"></a>规则1.1编写.C 和.H</h3><p>说明:每一个.c文件应有一-个同名.h文件，如果-一个.c文件不需要对外公布任何接口，则其就不应当存在，除非它是程序的入口，如main函数所在的文件。</p><h3 id="规则1-2编写内部保护符"><a href="#规则1-2编写内部保护符" class="headerlink" title="规则1.2编写内部保护符"></a>规则1.2编写内部保护符</h3><p>说明:总是编写内部#include保护符(#define 保护)，多次包含-一个头文件可以通过认真的设计来避免。如果不能做到这一一点，就需要采取阻止头文件内容被包含多于- -次的机制。</p><h3 id="规则1-3-编写头文件应当自包含"><a href="#规则1-3-编写头文件应当自包含" class="headerlink" title="规则1.3.编写头文件应当自包含"></a>规则1.3.编写头文件应当自包含</h3><p>说明:简单的说，自包含就是任意一一个头文件均可独 立编译.如果- -个文件包含某个头文件，还要包含另外- -个头文件才能工作的话，就会增加交流障碍，给这个头文件的用户增添不必要的负担。</p><h3 id="规则1-4禁止在头文件中定义变量"><a href="#规则1-4禁止在头文件中定义变量" class="headerlink" title="规则1.4禁止在头文件中定义变量"></a>规则1.4禁止在头文件中定义变量</h3><p>说明:在头文件中定义变量，将会由于头文件被其他.c文件包含而导致变量重复定义。</p><h3 id="规则1-5禁止头文件循环依赖"><a href="#规则1-5禁止头文件循环依赖" class="headerlink" title="规则1.5禁止头文件循环依赖"></a>规则1.5禁止头文件循环依赖</h3><p>说明:头文件循环依赖，指a.h包含b.h, b.h包含c.h， c.h 包含a.h之类导致任何一个头文件修改，都导致所有包含了a.h/b.h/c.h 的代码全部重新编译一遍。 而如果是单向依赖，如a.h包含b.h, b.h包含c.h,而c.h不包含任何头文件，则修改a.h不会导致包含了b.h/c.h 的源代码重新编译。</p><h3 id="规则1-6禁止包含用不到的头文件"><a href="#规则1-6禁止包含用不到的头文件" class="headerlink" title="规则1.6禁止包含用不到的头文件"></a>规则1.6禁止包含用不到的头文件</h3><p>说明: /.h 文件禁止包含用不到的头文件，很多系统中头文件包含关系复杂，开发人员为了省事起见，可能不会去一- -钻研， 直接包含- - 切想到的头文件，甚至有些产品干脆发布了一个god.h,其中包含了所有头文件，然后发布给各个项目组使用，这种只图一时省事的做法，导致整个系统的编译时间进一步 恶化，并对后来人的维护造成了巨大的麻烦。</p><h3 id="规则1-7禁止在-c中使用extern"><a href="#规则1-7禁止在-c中使用extern" class="headerlink" title="规则1.7禁止在.c中使用extern"></a>规则1.7禁止在.c中使用extern</h3><p>说明:在.c中通过exterm的方式使用外部函数接口或变量，只能通过包含头文件的方式使用其他.c提供的接口,若a.c使用了b.c 定义的foo()函数，则应当在b.h中声明extern int foo(intinput);并在a.c中通过#include.</p><h2 id="2、函数"><a href="#2、函数" class="headerlink" title="2、函数"></a>2、函数</h2><p>函数设计的精髓:编写整洁函数，同时把代码有效组织起来。</p><h3 id="原则2-1一函数一功能"><a href="#原则2-1一函数一功能" class="headerlink" title="原则2.1一函数一功能"></a>原则2.1一函数一功能</h3><p>说明:一个函数仅完成一-件功能，一个函数实现多个功能给开发、使用、维护都带来很大的困难。</p><h3 id="原则2-2代码提炼"><a href="#原则2-2代码提炼" class="headerlink" title="原则2.2代码提炼"></a>原则2.2代码提炼</h3><p>说明:重复代码应该尽可能提炼成函数，重复代码提炼成函数可以带来维护成本的降低。</p><h3 id="规则2-1避免函数超50行"><a href="#规则2-1避免函数超50行" class="headerlink" title="规则2.1避免函数超50行"></a>规则2.1避免函数超50行</h3><p>说明:避免函数过长，新增函数不超过50行(非空非注释行)。本规则仅对新增函数做要求，对已有函数修改时，建议不增加代码行。</p><h3 id="规则2-2避免超4嵌套"><a href="#规则2-2避免超4嵌套" class="headerlink" title="规则2.2避免超4嵌套"></a>规则2.2避免超4嵌套</h3><p>说明:避免函数的代码块嵌套过深，新增函数的代码块嵌套不超过4层，本规则仅对新增函数做要求，对已有的代码建议不增加嵌套层次。</p><h3 id="规则2-3避免重共享变量"><a href="#规则2-3避免重共享变量" class="headerlink" title="规则2.3避免重共享变量"></a>规则2.3避免重共享变量</h3><p>说明:可重入函数应避免使用共享变量:若需要使用，则应通过互斥手段(关中断、信号量)对其加以保护。可重入函数是指可能被多个任务并发调用的函数。在多任务操作系统中，函数具有可重入性是多个任务可以共用此函数的必要条件。共享变量指的全局变量和static变量。</p><h3 id="规则2-4处理参数合法性检查"><a href="#规则2-4处理参数合法性检查" class="headerlink" title="规则2.4处理参数合法性检查"></a>规则2.4处理参数合法性检查</h3><p>说明:由调用者负责还是由接口函数负责，应在项目组/模块内应统–规定。缺省由调用者负责。对于模块间接口函数的参数的合法性检查这- -问题，往往有两个极端现象，即:要么是调用者和被调用者对参数均不作合法性检查,结果就遗漏了合法性检查这一-必要的处理过程，造成问题隐患:要么就是调用者和被调用者均对参数进行合法性检查，这种情况虽不会造成问题，但产生了冗余代码，降低了效率。</p><h3 id="规则2-5处理错误码"><a href="#规则2-5处理错误码" class="headerlink" title="规则2.5处理错误码"></a>规则2.5处理错误码</h3><p>说明:对函数的错误返回码要全面处理。-一个函数(标准库中的函数/第三方库函数/用户定义的函数)能够提供一些指示错误发 生的方法。这可以通过使用错误标记、特殊的返回数据或者其他手段，不管什么时候函数提供了这样的机制，调用程序应该在函数返回时立刻检查错误指示。</p><h3 id="规则2-6处理扇入扇出"><a href="#规则2-6处理扇入扇出" class="headerlink" title="规则2.6处理扇入扇出"></a>规则2.6处理扇入扇出</h3><p>说明:设计高扇入，合理扇出(小于7)的函数。扇出是指-一个函数直接调用(控制)其它函数的数目，而扇入是指有多少上级函数调用它。</p><h3 id="规则2-7处理废弃代码"><a href="#规则2-7处理废弃代码" class="headerlink" title="规则2.7处理废弃代码"></a>规则2.7处理废弃代码</h3><p>说明:废弃代码(没有被调用的函数和变量)要及时清除。程序中的废弃代码不仅占用额外的空间，而且还常常影响程序的功能与性能，很可能给程序的测试、维护等造成不必要的麻烦。</p><h2 id="代码的建议"><a href="#代码的建议" class="headerlink" title="代码的建议"></a>代码的建议</h2><h3 id="建议2-1不变参数应固定"><a href="#建议2-1不变参数应固定" class="headerlink" title="建议2.1不变参数应固定"></a>建议2.1不变参数应固定</h3><p>说明:函数不变参数使用const.不变的值更易于理解/跟踪和分析，把const作为默认选项，在编译时会对其进行检查，使代码更牢固/更安全。</p><h3 id="建议2-2函数变量应临时"><a href="#建议2-2函数变量应临时" class="headerlink" title="建议2.2函数变量应临时"></a>建议2.2函数变量应临时</h3><p>说明:函数应避免使用全局变量、静态局部变量和1/0操作，不可避免的地方应集中使用。带有内部“存储器”的函数的功能可能是不可预测的，因为它的输出可能取决于内部存储器(如某标记)的状态。这样的函数既不易于理解又不利于测试和维护。在C语言中，函数的static局部变量是函数的内部存储器，有可能使函数的功能不可预测，然而，当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类，则返回为错针。</p><h3 id="建议2-3有效性参数应检查"><a href="#建议2-3有效性参数应检查" class="headerlink" title="建议2.3有效性参数应检查"></a>建议2.3有效性参数应检查</h3><p>说明:检查函数所有非参数输入的有效性，如数据文件、公共变量等。</p><p>函数的输入主要有两种: -种是参数输入: 另一种是全局变量、数据文件的输入，即非参数输入。函数在使用输入参数之前，应进行有效性检查。</p><h3 id="建议2-4参数个数应少5"><a href="#建议2-4参数个数应少5" class="headerlink" title="建议2.4参数个数应少5"></a>建议2.4参数个数应少5</h3><p>说明:函数的参数个数不超过5 个。函数的参数过多，会使得该函数易于受外部(其他部分的代码)变化的影响，从而影响维护工作。函数的参数过多同时也会增大测试的工作量。</p><h3 id="建议2-5参数长度应固定"><a href="#建议2-5参数长度应固定" class="headerlink" title="建议2.5参数长度应固定"></a>建议2.5参数长度应固定</h3><p>说明:除打印类函数外，不要使用可变长参函数。可变长参函数的处理过程比较复杂容易引入错误，而且性能也比较低，使用过多的可变长参函数将导致函数的维护难度大大增加。</p><h3 id="建议2-6非外用应静态"><a href="#建议2-6非外用应静态" class="headerlink" title="建议2.6非外用应静态"></a>建议2.6非外用应静态</h3><p>说明:在源文件范围内声明和定义的所有函数，除非外部可见，否则应该增加static关键字。如果一个函数只是在同一文件中的其他地方调用，那么就用static声明。使用static确保只是在声明它的文件中是可见的，并且避免了和其他文件或库中的相同标识符发生混淆的可能性。</p><h3 id="建议2-7规范应统一"><a href="#建议2-7规范应统一" class="headerlink" title="建议2.7规范应统一"></a>建议2.7规范应统一</h3><p>a. 小写字母开头大写字母链接间隔区分，如uteHalayerxxx.</p><p>b. 函數开头包含函数主体名，如ute_ hal layer.c, 里面的函数都用uteHalLayer开头。格式为:文件主体名+功能名。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="技巧篇" scheme="https://tqoqt.github.io/categories/%E6%8A%80%E5%B7%A7%E7%AF%87/"/>
    
    
  </entry>
  
  <entry>
    <title>Arduino_ESP32开发</title>
    <link href="https://tqoqt.github.io/posts/rtt1.html"/>
    <id>https://tqoqt.github.io/posts/rtt1.html</id>
    <published>2021-12-05T16:00:00.000Z</published>
    <updated>2021-12-05T16:22:15.990Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1、关键字"><a href="#1、关键字" class="headerlink" title="1、关键字"></a>1、关键字</h1><h2 id=""><a href="#" class="headerlink" title=";"></a>;</h2><p>;是一条语句结束的标志，供编译器识别，必须得有。</p><h2 id="-1"><a href="#-1" class="headerlink" title="{}"></a>{}</h2><p>{}将多条语句合成一个复合语句，能划分语句的<a href="https://www.zhihu.com/search?q=%E4%BD%9C%E7%94%A8%E5%9F%9F&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:98195874%7D">作用域</a>，增强整体整体的可读性。</p><h2 id="-2"><a href="#-2" class="headerlink" title="//"></a>//</h2><p>//行注释，该行//后的所有语句，文字将不被<a href="https://www.zhihu.com/search?q=%E7%BC%96%E8%AF%91%E5%99%A8&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:98195874%7D">编译器</a>所编译、执行。相似的，还有，在中的所有语句，文字将不被编译器所编译、执行。</p><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>if(<a href="https://www.zhihu.com/search?q=%E8%A1%A8%E8%BE%BE%E5%BC%8F&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:98195874%7D">表达式</a>)<br>{<br>语句A;<br>}</p><h2 id="if-else-if-else"><a href="#if-else-if-else" class="headerlink" title="if_else if_else"></a>if_else if_else</h2><p>if(表达式1)<br>{<br>语句1；<br>}<br>else if(表达式2)<br>{<br>语句2；<br>}<br>…<br>else if(表达式n)<br>{<br>语句n；<br>}<br>else<br>{<br>语句n+1；<br>}</p><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>for(初始表达式；条件表达式；循环变量表达式)<br>{<br>循环体语句；<br>}</p><h2 id="switch-case-default"><a href="#switch-case-default" class="headerlink" title="switch_case_default"></a>switch_case_default</h2><p>switch(表达式)<br>{<br>case 表达式常量1:语句序列1；<br>case 表达式常量2:语句序列2；<br>…<br>case 表达式常量i:语句序列i；<br>case 表达式常量n:语句序列n；<br>default:语句序列n+1；<br>}</p><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>while(条件表达式)<br>{<br>循环语句；<br>循环变量表达式；<br>}</p><h2 id="do-while"><a href="#do-while" class="headerlink" title="do_while"></a>do_while</h2><p>do<br>{<br>循环体语句；<br>}while(条件表达式);</p><h1 id="2、数据类型"><a href="#2、数据类型" class="headerlink" title="2、数据类型"></a>2、数据类型</h1><h1 id="3、常量"><a href="#3、常量" class="headerlink" title="3、常量"></a><img src="https://pic3.zhimg.com/v2-a9beeb2dccec70af96350c1274f86942_r.jpg" alt="preview"><strong>3、常量</strong></h1><p>HIGH | LOW 表示数字IO口的高低电平。HIGH 表示高电（1），LOW 表示<a href="https://www.zhihu.com/search?q=%E4%BD%8E%E7%94%B5%E5%B9%B3&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:98195874%7D">低电平</a>（0）。<br>INPUT | OUTPUT 表示数字IO口的方向，INPUT 表示输入（高阻态），OUTPUT 表示输出（AVR单片机能提供5V电压 40mA电流）。<br>true | false true 表示真（1），false表示假（0）。</p><h1 id="4、程序结构"><a href="#4、程序结构" class="headerlink" title="4、程序结构"></a>4、<strong>程序结构</strong></h1><p>声明变量及接口名称（例如：int i;int ledPin=13;）。<br>void setup() 函数在程序开始时使用，初始化变量，管脚模式，调用库函数等（例如：pinMode(ledPin,OUTUPT);）。相当于main（）函数中while函数之前的作用</p><p>void loop() 在void setup()函数之后，即初始化之后，loop() 让你的程序循环地被执行。使用它来运转Arduino。相当于while（）函数</p><h1 id="5、-数字-I-O"><a href="#5、-数字-I-O" class="headerlink" title="5、 数字 I/O"></a>5、 <strong>数字 I/O</strong></h1><p>以下型号为UNO</p><h2 id="pinMode-pin-mode"><a href="#pinMode-pin-mode" class="headerlink" title="pinMode(pin, mode);"></a>pinMode(pin, mode);</h2><p>数字IO口输入输出模式定义函数，pin表示为0～13， mode表示INPUT或OUTPUT。</p><h2 id="digitalWrite-pin-value"><a href="#digitalWrite-pin-value" class="headerlink" title="digitalWrite(pin, value) ;"></a>digitalWrite(pin, value) ;</h2><p>数字IO口输出电平定义函数，pin表示为0～13，value表示为HIGH或LOW。<br><strong>必须先定义为输入或输出模式</strong>digitalWrite才能生效。</p><h2 id="int-digitalRead-pin"><a href="#int-digitalRead-pin" class="headerlink" title="int digitalRead(pin);"></a>int digitalRead(pin);</h2><p>数字IO口读输入电平函数，pin表示为0～13，value表示为HIGH或LOW。比如可以读数<br>字传感器。</p><h1 id="6、-模拟IO"><a href="#6、-模拟IO" class="headerlink" title="6、 模拟IO"></a>6、 <strong>模拟IO</strong></h1><h2 id="int-analogRead-pin"><a href="#int-analogRead-pin" class="headerlink" title="int analogRead(pin);"></a>int analogRead(pin);</h2><p>模拟IO口读函数，pin表示为0～5（ArduinoDiecimila为0～5，Arduino nano为0～7）。比如可以读模拟传感器（10位AD，0～5V表示为0～1023）。</p><h2 id="analogWrite-pin-value-PWM"><a href="#analogWrite-pin-value-PWM" class="headerlink" title="analogWrite(pin, value) - PWM"></a>analogWrite(pin, value) - PWM</h2><p>数字IO口PWM输出函数，Arduino数字IO口标注了PWM的IO口可使用该函数通常在引脚的旁边标注~，pin表示3, 5, 6, 9,10, 11，value表示为0～255。比如可用于电机PWM调速或音乐播放。</p><h1 id="7-、扩展-I-O"><a href="#7-、扩展-I-O" class="headerlink" title="7.、扩展 I/O"></a>7.、<strong>扩展 I/O</strong></h1><h2 id="shiftOut-dataPin-clockPin-bitOrder-value-；"><a href="#shiftOut-dataPin-clockPin-bitOrder-value-；" class="headerlink" title="shiftOut(dataPin, clockPin, bitOrder,value)；"></a>shiftOut(dataPin, clockPin, bitOrder,value)；</h2><p>SPI外部IO扩展函数，通常使用带SPI接口的74HC595做8个IO扩展，dataPin为数据口，clockPin为时钟口，bitOrder为数据传输方向（MSBFIRST高位在前，LSBFIRST低位在前），value表示所要传送的数据（0～255），另外还需要一个IO口做74HC595的使能控制。</p><h2 id="unsigned-long-pulseIn-pin-value-；"><a href="#unsigned-long-pulseIn-pin-value-；" class="headerlink" title="unsigned long pulseIn(pin, value)；"></a>unsigned long pulseIn(pin, value)；</h2><p><a href="https://www.zhihu.com/search?q=%E8%84%89%E5%86%B2%E9%95%BF%E5%BA%A6%E8%AE%B0%E5%BD%95%E5%87%BD%E6%95%B0&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:98195874%7D">脉冲长度记录函数</a>，返回时间参数（us），pin表示为0～13，value为HIGH或LOW。比如value为HIGH，那么当pin输入为<a href="https://www.zhihu.com/search?q=%E9%AB%98%E7%94%B5%E5%B9%B3&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:98195874%7D">高电平</a>时，开始计时，当pin输入为低电平时，停止计时，然后返回该时间。</p><h1 id="8、时间函数"><a href="#8、时间函数" class="headerlink" title="8、时间函数"></a>8、<strong>时间函数</strong></h1><h2 id="unsigned-long-millis-；"><a href="#unsigned-long-millis-；" class="headerlink" title="unsigned long millis()；"></a>unsigned long millis()；</h2><p>返回时间函数（单位ms），该函数是指，当程序运行就开始计时并返回记录的参数，该参数溢出大概需要50天时间。</p><h2 id="delay-ms-；"><a href="#delay-ms-；" class="headerlink" title="delay(ms)；"></a>delay(ms)；</h2><p>延时函数（单位ms）。</p><h2 id="delayMicroseconds-us-；"><a href="#delayMicroseconds-us-；" class="headerlink" title="delayMicroseconds(us)；"></a>delayMicroseconds(us)；</h2><p>延时函数（单位us）。</p><h1 id="9、-数学函数"><a href="#9、-数学函数" class="headerlink" title="9、**数学函数**"></a>9、**<a href="https://www.zhihu.com/search?q=%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:98195874%7D">数学函数</a>**</h1><h2 id="min-x-y"><a href="#min-x-y" class="headerlink" title="min(x, y) ;"></a>min(x, y) ;</h2><p>求最小值。</p><h2 id="max-x-y"><a href="#max-x-y" class="headerlink" title="max(x, y) ;"></a>max(x, y) ;</h2><p>求最大值。</p><h2 id="abs-x"><a href="#abs-x" class="headerlink" title="abs(x) ;"></a>abs(x) ;</h2><p> 计算<a href="https://www.zhihu.com/search?q=%E7%BB%9D%E5%AF%B9%E5%80%BC&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:98195874%7D">绝对值</a>。</p><h2 id="constrain-x-a-b"><a href="#constrain-x-a-b" class="headerlink" title="constrain(x, a, b) ;"></a>constrain(x, a, b) ;</h2><p>约束函数，下限a，上限b，x必须在ab之间才能返回。</p><h2 id="map-value-fromLow-fromHigh-toLow-toHigh"><a href="#map-value-fromLow-fromHigh-toLow-toHigh" class="headerlink" title="map(value, fromLow, fromHigh, toLow,toHigh);"></a>map(value, fromLow, fromHigh, toLow,toHigh);</h2><p>约束函数，value必须在fromLow与toLow之间和fromHigh与toHigh之间。</p><h2 id="pow-base-exponent"><a href="#pow-base-exponent" class="headerlink" title="pow(base, exponent);"></a>pow(base, exponent);</h2><p>开方函数，base的exponent次方。</p><h2 id="sq-x"><a href="#sq-x" class="headerlink" title="sq(x);"></a>sq(x);</h2><p> 平方。</p><h2 id="sqrt-x"><a href="#sqrt-x" class="headerlink" title="sqrt(x);"></a>sqrt(x);</h2><p>开根号。<br><a href="https://www.zhihu.com/search?q=%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:98195874%7D">三角函数</a>：<br>sin(rad);<br>cos(rad);<br>tan(rad);</p><h1 id="10、-随机数函数"><a href="#10、-随机数函数" class="headerlink" title="10、**随机数函数**"></a>10、**<a href="https://www.zhihu.com/search?q=%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%87%BD%E6%95%B0&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:98195874%7D">随机数函数</a>**</h1><h2 id="randomSeed-seed-；"><a href="#randomSeed-seed-；" class="headerlink" title="randomSeed(seed)；"></a>randomSeed(seed)；</h2><p>随机数端口定义函数，seed表示读模拟口analogRead(pin)函数 。</p><h2 id="long-random-max-；"><a href="#long-random-max-；" class="headerlink" title="long random(max)；"></a>long random(max)；</h2><p>随机数函数，返回数据大于等于0，小于max。</p><h2 id="long-random-min-max-；"><a href="#long-random-min-max-；" class="headerlink" title="long random(min, max)；"></a>long random(min, max)；</h2><p>随机数函数，返回数据大于等于min，小于max。</p><h1 id="11、外部中断函数"><a href="#11、外部中断函数" class="headerlink" title="11、外部中断函数"></a>11、<strong>外部中断函数</strong></h1><h2 id="attachInterrupt-interrupt-mode；"><a href="#attachInterrupt-interrupt-mode；" class="headerlink" title="attachInterrupt(interrupt, , mode；"></a>attachInterrupt(interrupt, , mode；</h2><p>外部中断只能用到数字IO口2和3，interrupt表示中断口初始0或1，表示一个功能函数，mode：LOW低电平中断，CHANGE有变化就中断，RISING上升沿中断，FALLING 下降沿中断。</p><h2 id="detachInterrupt-interrupt-；"><a href="#detachInterrupt-interrupt-；" class="headerlink" title="detachInterrupt(interrupt)；"></a>detachInterrupt(interrupt)；</h2><p>中断开关，interrupt=1 开，interrupt=0 关。</p><h2 id="interrupts-；"><a href="#interrupts-；" class="headerlink" title="interrupts()；"></a>interrupts()；</h2><p>中断使能函数，用于使能中断。</p><h2 id="noInterrupts-；"><a href="#noInterrupts-；" class="headerlink" title="noInterrupts()；"></a>noInterrupts()；</h2><p>中断禁止函数，禁止中断。</p><h1 id="12、串口收发函数"><a href="#12、串口收发函数" class="headerlink" title="12、串口收发函数"></a>12、<strong>串口收发函数</strong></h1><p>Serial.begin(speed)；串口定义波特率函数，speed表示<a href="https://www.zhihu.com/search?q=%E6%B3%A2%E7%89%B9%E7%8E%87&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:98195874%7D">波特率</a>（串行每秒传输数据位数的速率），如9600，19200等。<br>int Serial.available() 判断<a href="https://www.zhihu.com/search?q=%E7%BC%93%E5%86%B2%E5%99%A8&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:98195874%7D">缓冲器</a>状态。<br>int Serial.read()；读串口并返回收到参数。<br>Serial.flush()；清空缓冲器。<br>Serial.print(data)；串口输出数据。Serial.print(数据，数据的进制) 默认为<a href="https://www.zhihu.com/search?q=%E5%8D%81%E8%BF%9B%E5%88%B6&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:98195874%7D">十进制</a>（DEC）<br>Serial.println(data)；串口输出数据并带回车符。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="开发语言" scheme="https://tqoqt.github.io/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="keil" scheme="https://tqoqt.github.io/tags/keil/"/>
    
    <category term="Arduino" scheme="https://tqoqt.github.io/tags/Arduino/"/>
    
  </entry>
  
  <entry>
    <title>ESP32学习</title>
    <link href="https://tqoqt.github.io/posts/esp32.html"/>
    <id>https://tqoqt.github.io/posts/esp32.html</id>
    <published>2021-11-10T01:00:00.000Z</published>
    <updated>2021-11-23T16:42:10.665Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ESP32"><a href="#ESP32" class="headerlink" title="ESP32"></a>ESP32</h1><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><p>ESP IDF</p><h1 id="1-ESP32单片机开发框架"><a href="#1-ESP32单片机开发框架" class="headerlink" title="1.ESP32单片机开发框架"></a>1.ESP32单片机开发框架</h1><h3 id="Arduino"><a href="#Arduino" class="headerlink" title="Arduino"></a>Arduino</h3><p>单片机底层</p><h3 id="Micropython"><a href="#Micropython" class="headerlink" title="Micropython"></a>Micropython</h3><p><a href="http://www.micropython.org/">http://www.micropython.org</a></p><h3 id="分布式版本控制"><a href="#分布式版本控制" class="headerlink" title="分布式版本控制"></a>分布式版本控制</h3><p>每个人拥有全部代码，可以存储在本地，有网时上传到服务器中</p><h1 id="2-环境配置"><a href="#2-环境配置" class="headerlink" title="2.环境配置"></a>2.环境配置</h1><h2 id="1、VScode-platformlO-IDE"><a href="#1、VScode-platformlO-IDE" class="headerlink" title="1、VScode+platformlO IDE"></a>1、VScode+platformlO IDE</h2><h2 id="2、VScode-Arduino"><a href="#2、VScode-Arduino" class="headerlink" title="2、VScode+Arduino"></a>2、VScode+Arduino</h2><p>最终选择VScode+PLatformlo IDE配置开发环境</p><h1 id="3、程序"><a href="#3、程序" class="headerlink" title="3、程序"></a>3、程序</h1><h2 id="1、点亮LED灯"><a href="#1、点亮LED灯" class="headerlink" title="1、点亮LED灯"></a>1、点亮LED灯</h2><pre class="line-numbers language-Ｃ" data-language="Ｃ"><code class="language-Ｃ">void setup() {  // put your setup code here, to run once:  pinMode(D4,OUTPUT);}void loop() {  // put your main code here, to run repeatedly:  digitalWrite(D4,HIGH);  delay(200);  digitalWrite(D4,LOW);  delay(200);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="２、连接WIFI打印IP"><a href="#２、连接WIFI打印IP" class="headerlink" title="２、连接ＷＩＦＩ打印IP"></a>２、连接ＷＩＦＩ打印IP</h2><pre class="line-numbers language-Ｃ" data-language="Ｃ"><code class="language-Ｃ">#include &lt;ESP8266WiFi.h&gt;//获取ESP8266连接的WIFI的IPconst char* ssid = "Xiaomi_69FC";const char* password = "502niubi.";void setup() {  // put your setup code here, to run once:  Serial.begin(115200);  WiFi.begin(ssid,password);  while(WiFi.status() != WL_CONNECTED)  {    delay(500);    Serial.println(".");    }  Serial.println("");  Serial.println("WiFi connected");  Serial.println(WiFi.localIP());}void loop() {  // put your main code here, to run repeatedly:}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="３、获取百度网页源代码"><a href="#３、获取百度网页源代码" class="headerlink" title="３、获取百度网页源代码"></a>３、获取百度网页源代码</h2><pre class="line-numbers language-ｃ" data-language="ｃ"><code class="language-ｃ">#include &lt;WiFi.h&gt;//wifi参数const char* ssid = "zsf";const char* password = "123456789";//Hostconst char* host = "www.baidu.com";void setup() {  // put your setup code here, to run once:  Serial.begin(115200);  Serial.println();  Serial.println();  Serial.print("Connecting to ");  Serial.println(ssid);  WiFi.begin(ssid,password);  while(WiFi.status() != WL_CONNECTED)  {    delay(500);    Serial.print(".");    }  Serial.println("");  Serial.println("WiFi connected");  Serial.println("IP address: ");  Serial.println(WiFi.localIP());}int value = 0;void loop() {  // put your main code here, to run repeatedly:  Serial.print("Connecting to ");  Serial.println(host);  //使用WIFIClient类创建TCP连接  WiFiClient client;  const int httpPort = 80;  if(!client.connect(host,httpPort))  {    Serial.println("connection failed");    return;    }  client.print(String("GET /") + " HTTP/1.1\r\n" +  "Host: " + host + "\r\n" + "Connection: close\r\n\r\n");   delay(200);  while(client.available())  {    String line = client.readStringUntil('\r');    Serial.print(line);  }  Serial.println();  Serial.println("closing connection");  delay(500); }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="学习篇" scheme="https://tqoqt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
    
    <category term="ESP32" scheme="https://tqoqt.github.io/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>RT_Thread Nano移植到Keil</title>
    <link href="https://tqoqt.github.io/posts/rtt1.html"/>
    <id>https://tqoqt.github.io/posts/rtt1.html</id>
    <published>2021-10-27T16:00:00.000Z</published>
    <updated>2021-10-29T12:09:51.853Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr><pre class="line-numbers language-c" data-language="c"><code class="language-c">Internal command error<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改board.c中的USART要选对串口才能下载成功出现功能</p><h1 id="1、报错"><a href="#1、报错" class="headerlink" title="1、报错"></a>1、报错</h1><h2 id="1-1、Error-L6218E-Undefined-symbol-rt-thread-create-r"><a href="#1-1、Error-L6218E-Undefined-symbol-rt-thread-create-r" class="headerlink" title="1.1、Error: L6218E: Undefined symbol rt_thread_create (r"></a>1.1、Error: L6218E: Undefined symbol rt_thread_create (r</h2><h3 id="1-1-1在让他从fig-h中找到-define-RT-USING-HEAP去除注释"><a href="#1-1-1在让他从fig-h中找到-define-RT-USING-HEAP去除注释" class="headerlink" title="1.1.1在让他从fig.h中找到#define RT_USING_HEAP去除注释"></a>1.1.1在让他从fig.h中找到#define RT_USING_HEAP去除注释</h3><h1 id="2、功能"><a href="#2、功能" class="headerlink" title="2、功能"></a>2、功能</h1><p>开启动态线程，要打开rtconfig.h中的#define RT_USING_HEAP</p><p><strong>与裸机 LED 闪烁应用代码的不同</strong>：</p><p>1). 延时函数不同： RT-Thread 提供的 <code>rt_thread_mdelay()</code> 函数可以引起操作系统进行调度，当调用该函数进行延时时，本线程将不占用 CPU，调度器切换到系统的其他线程开始运行。而裸机的 delay 函数是一直占用 CPU 运行的。</p><p>2). 初始化系统时钟的位置不同：移植好 RT-Thread Nano 之后，不需要再在 main() 中做相应的系统配置（如 hal 初始化、时钟初始化等），这是因为 RT-Thread 在系统启动时，已经做好了系统时钟初始化等的配置，这在上一小节 “系统时钟配置” 中有讲解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="操作系统" scheme="https://tqoqt.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="keil" scheme="https://tqoqt.github.io/tags/keil/"/>
    
    <category term="RT_Thread" scheme="https://tqoqt.github.io/tags/RT-Thread/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://tqoqt.github.io/posts/dai-ma-gui-fan.html"/>
    <id>https://tqoqt.github.io/posts/dai-ma-gui-fan.html</id>
    <published>2021-10-26T16:00:00.000Z</published>
    <updated>2021-10-27T09:19:17.608Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h1><h2 id="1、总体原则"><a href="#1、总体原则" class="headerlink" title="1、总体原则"></a>1、总体原则</h2><ol><li>简洁明了</li><li>清晰</li><li>和原有风格保持一致</li></ol><h2 id="2、头文件"><a href="#2、头文件" class="headerlink" title="2、头文件"></a>2、头文件</h2><ol><li>头文件职责单一，切忌依赖复杂：如不能包含过多头文件</li><li>每一个C文件应有一个同名的H文件，用于声明需对外公开的接口</li><li>禁止头文件循环依赖，只能是单向依赖</li><li>禁止包含用不到的头文件</li><li>头文件应当自包含，不需要别的头文件才能编译</li><li>禁止在头文件中定义变量</li><li>只能通过包含头文件的方式使用其他C文件提供的接口，禁止在C文件中通过extern的方式使用外部函数接口、变量</li><li>禁止在extern “C”中包含头文件</li><li></li></ol><h2 id="3、函数"><a href="#3、函数" class="headerlink" title="3、函数"></a>3、函数</h2><ol><li>一个函数仅完成一个功能</li><li>重复代码应该尽可能提炼成函数</li><li>函数避免过长</li><li>函数代码嵌套过深（尽量不超过四层）</li><li>可重入函数（可能被多个任务并发调用的函数）避免使用共享变量；如需使用，则应通过互斥手段（关中断、信号量）对其加以保护</li><li>设计高扇入，合理扇出的函数（小于七）：扇出指一个函数直接调用（控制）其他函数的数目，扇入指有多少上级函数调用它</li><li>函数应避免使用全局变量、静态局部变量和I/O操作，不可避免的地方集中操作</li><li>函数的参数个数不超过5个</li></ol><h2 id="4、标识符命名与定义"><a href="#4、标识符命名与定义" class="headerlink" title="4、标识符命名与定义"></a>4、标识符命名与定义</h2><ol><li>标识符命名要清晰明了、尽量使用完整的单词或大家都能理解的缩写</li><li>除常用通用的缩写外，不得使用单词缩写和汉语拼音，尤其拼音缩写</li><li>命名风格内部要保持一致</li><li>用反义词命名具有互斥意义的变量或相反动作的函数</li><li>尽量避免名字中出现数字编号</li><li>标识符前不添加模块、项目、产品、部门等名称作为前缀</li><li>由于不同系统对文件名大小写处理会不同，所以代码文件命名建议统一采用全小写字母命名</li><li>除头文件或编译开关等特殊标识定义，宏定义不能使用下划线开头或结尾</li></ol><h2 id="5、变量"><a href="#5、变量" class="headerlink" title="5、变量"></a>5、变量</h2><ol><li>一个变量只能有一个功能，不能把一个变量用作多种用途</li><li>不用或少用全局变量</li><li>局部变量与全局变量不要同名</li><li>严禁使用未经初始化的变量作为右值</li><li>尽量减少没有必要的数据类型默认转换与强制转换</li></ol><h2 id="6、宏、常量"><a href="#6、宏、常量" class="headerlink" title="6、宏、常量"></a>6、宏、常量</h2><ol><li><p>用宏定义表达式时，要使用完备的括号</p></li><li><p>使用宏时，不允许参数发生变化</p></li><li><p>除非必要，应尽可能使用函数代替宏</p></li><li><p>常量建议使用const定义代替宏</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define ASPECT_RATIO 1.653<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编译器会永远也看不到ASPECT_RATIO这个符号名，因为在源码进入编译器之前，它会被预处理程序去掉，于是ASPECT_RATIO不会加入到符号列表中。如果涉及到这个常量的代码在编译时报错，就会很令人费解，因为报错信息指的是1.653，而不是ASPECT_RATIO。如果ASPECT_RATIO不是在你自己写的头文件中定义的，你就会奇怪1.653是从哪里来的，甚至会花时间跟踪下去。这个问题也会出现在符号调试器中，因为同样地，你所写的符号名不会出现在符号列表中。<br>解决这个问题的方案很简单：不用预处理宏，定义一个常量：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">const double ASPECT_RATIO = 1.653;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种方法很有效，但有两个特殊情况要注意。首先，定义指针常量时会有点不同。因为常量定义一般是放在头文件中（许多源文件会包含它），除了指针所指的类型要定义成const外，重要的是指针也经常要定义成const。例如，要在头文件中定义一个基于char*的字符串常量，你要写两次const：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">const char * const authorName = "Scott Meyers";<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>宏定义中尽量不使用return、goto、continue、break等改变程序流程的语句</p></li></ol><h2 id="6、表达式"><a href="#6、表达式" class="headerlink" title="6、表达式"></a>6、表达式</h2><ol><li>函数调用不要作为另一个函数的参数使用，否则对于代码的调试、阅读都不利</li><li>赋值语句不要写在if等语句中，或作为函数的参数使用<ol><li>因为if语句中，会根据条件依次判断，如果前一个条件已经可以判定整个条件，则后续条件语句不会再运行，所以可能导致期望的部分赋值没有得到运行。</li></ol></li><li>用括号明确表达式的操作顺序，避免过分依赖默认优先级</li></ol><h2 id="7、注释"><a href="#7、注释" class="headerlink" title="7、注释"></a>7、注释</h2><ol><li>注释内容要清晰明了、含义准确，防止代码二义性</li><li>注释解释代码难以直接表达的意图，而不是重复描述代码</li><li>修改代码时，维护代码周边的所有注释，保持注释代码的一致性</li><li>文件头部应注释，注释必须列出：版权、版本号、生成日期、作者姓名、内容、功能说明、和其他文件的关系、修改日志</li><li>函数声明注释要描述函数的功能、性能及用法、输入和输出参数、函数返回值、可重入的要求</li><li>注释应放在代码上方或右方、不可放在下面，放在上方要和其上方代码用空行隔开</li><li>对于switch语句下的case语句，如果因为特殊情况需要处理完一个case后进入下一个case处理，必须在该case语句处理完、下一个case语句前加上明确的注释</li><li>注释中避免使用缩写</li><li>严禁在一行代码或表达式的中间插入注释</li></ol><h2 id="8、排版与格式"><a href="#8、排版与格式" class="headerlink" title="8、排版与格式"></a>8、排版与格式</h2><ol><li>相对独立的程序块之间、变量说明之后必须加空行</li><li>多个短语局不允许写在同一行</li><li>if、for、do、while、case、switch、default等语句独占一行</li><li>操作符之间看情况加空格<ol><li>逗号“，”封号“；”只在后面加空格</li><li>比较操作符，赋值操作符“=”、“+=”，算数操作符“+”，“%”，逻辑操作符“&amp;&amp;”、“&amp;”，位域操作符“&lt;&lt;”、“^”等双目操作符的前后加空格</li><li>“!”、”~”、”++”、”–”、“&amp;”等单目操作符前后不加空格</li><li>“-&gt;”、“.”前后不加空格</li><li>if、for、while、switch等与后面的括号间应加空格，师关键字更为突出、明显</li><li>注释符（包括/**/、//）与注释内容之间要用一个空格进行分隔</li></ol></li><li>源程序中关系较为紧密的代码应尽可能相邻</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="学习篇" scheme="https://tqoqt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
    
    <category term="代码规范" scheme="https://tqoqt.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://tqoqt.github.io/posts/github.html"/>
    <id>https://tqoqt.github.io/posts/github.html</id>
    <published>2021-10-25T16:00:00.000Z</published>
    <updated>2021-10-27T11:24:16.196Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="github访问解决方法"><a href="#github访问解决方法" class="headerlink" title="github访问解决方法"></a>github访问解决方法</h1><h2 id="1、以管理员身份运行命令提示符"><a href="#1、以管理员身份运行命令提示符" class="headerlink" title="1、以管理员身份运行命令提示符"></a>1、以管理员身份运行命令提示符</h2><p><img src="https://cdn.jsdelivr.net/gh/TQOQT/picgobed/img/202110261937678.jpeg" alt="img"></p><p><u>优化方法：绕过DNS解析，直接在**<strong>本地绑定host</strong></u></p><h2 id="2、在站长工具查询GitHub-com"><a href="#2、在站长工具查询GitHub-com" class="headerlink" title="2、在站长工具查询GitHub.com"></a>2、<a href="**http://tool.chinaz.com/dns**">在站长工具</a>查询GitHub.com</h2><p>选择TTL值小的ＩＰ地址<img src="https://cdn.jsdelivr.net/gh/TQOQT/picgobed/img/202110261941353.jpeg" alt="img"></p><h2 id="３、打开本地电脑的C-Windows-System32-drivers-etc目录，找到hosts文件"><a href="#３、打开本地电脑的C-Windows-System32-drivers-etc目录，找到hosts文件" class="headerlink" title="３、打开本地电脑的C:\Windows\System32\drivers\etc目录，找到ｈｏｓｔｓ文件"></a>３、打开本地电脑的C:\Windows\System32\drivers\etc目录，找到ｈｏｓｔｓ文件<img src="https://cdn.jsdelivr.net/gh/TQOQT/picgobed/img/202110261942429.jpeg" alt="img"></h2><h2 id="４、文本工具在最后面打开hosts文件"><a href="#４、文本工具在最后面打开hosts文件" class="headerlink" title="４、文本工具在最后面打开ｈｏｓｔｓ文件"></a>４、文本工具在最后面打开ｈｏｓｔｓ文件</h2><p>在最后一行添加查询到的IP地址</p><p><img src="https://cdn.jsdelivr.net/gh/TQOQT/picgobed/img/202110261943712.jpeg" alt="img"></p><h2 id="５、再在命令提示符中ping-GitHub．com"><a href="#５、再在命令提示符中ping-GitHub．com" class="headerlink" title="５、再在命令提示符中ｐｉｎｇ　GitHub．ｃｏｍ"></a>５、再在命令提示符中ｐｉｎｇ　GitHub．ｃｏｍ</h2><p><img src="https://cdn.jsdelivr.net/gh/TQOQT/picgobed/img/202110261943653.jpeg" alt="img"></p><p>成功则会显示如此</p><p>最后网页打开速度会提高</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="技巧篇" scheme="https://tqoqt.github.io/categories/%E6%8A%80%E5%B7%A7%E7%AF%87/"/>
    
    
    <category term="GitHub" scheme="https://tqoqt.github.io/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>RT_Thread</title>
    <link href="https://tqoqt.github.io/posts/rtt1.html"/>
    <id>https://tqoqt.github.io/posts/rtt1.html</id>
    <published>2021-09-07T16:00:00.000Z</published>
    <updated>2021-10-28T11:13:28.035Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr><p> 学习RT_Thread一定要坚持下去啊，为了跳槽啊！！！！！</p><p><img src="https://cdn.jsdelivr.net/gh/TQOQT/picgobed/img/202110261907685.png" alt="QQ002"></p><h2 id="1、初识RT-Thread"><a href="#1、初识RT-Thread" class="headerlink" title="1、初识RT_Thread"></a>1、初识RT_Thread</h2><p>生活常见的：电视机顶盒、路由器、电冰箱、微波炉。</p><p>嵌入式操作系统是应用在嵌入式系统的软件，对接嵌入式底层硬件与上层应用。在多任务管理、任务间通信、内存管理、定时器管理、设备管理。提供一套完整的机制，极大程度上便利嵌入式应用程序的开发、管理和维护</p><p>诞生于2006年</p><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ol><li>MDK安装</li><li>示例代码<ol><li>src：RT_Thread内核代码文件</li><li>libcpu：各类芯片/内核移植代码，比如STM</li><li>include：RT_Thread内核头文件</li><li>components：RT_Thread外部组件代码，比如Finsh、Lwip</li></ol></li></ol><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="1、特点（优势）"><a href="#1、特点（优势）" class="headerlink" title="1、特点（优势）"></a>1、特点（优势）</h2><p>是一个集实时操作系统内核、中间件组件和开发者社区一体的技术平台，是一个组件完整丰富、高度可伸缩、简易开发、超低功耗、高安全性的物联网操作系统。具备一个IOT OS平台所需的所有关键组件。支持市面上所有主流的编译工具如GCC、Keil、IAR等，工具链完善、友好、支持各类标准接口，几乎支持市面上所有WiFi、MCU芯片</p><h2 id="2、概述"><a href="#2、概述" class="headerlink" title="2、概述"></a>2、概述</h2><ol><li>RT_Thread全称是Real Time-Thread，是一个嵌入式实时多线程操作系统，基本属性之一是支持多任务，在RT-Thread系统中任务是通过多线程实现的</li><li>相较于Linux操作系统，其体积小，成本低，功耗低，启动快速，而且还实时性高、占用资源小等特点，非常实用与各种资源受限的场合</li></ol><h1 id="一、第一章"><a href="#一、第一章" class="headerlink" title="一、第一章"></a>一、第一章</h1><h2 id="1、常见操作系统"><a href="#1、常见操作系统" class="headerlink" title="1、常见操作系统"></a>1、常见操作系统</h2><ol><li>windows、Linux、Mac</li><li>安卓操作系统、IOS</li><li>鸿蒙</li></ol><h2 id="2、架构"><a href="#2、架构" class="headerlink" title="2、架构"></a>2、架构</h2><p>与其他的RTOS如Free RTOS、uC/OS的主要区别之一是，它不仅仅是一个实时内核，还具备丰富的中间层组件</p><p><img src="https://cdn.jsdelivr.net/gh/TQOQT/picgobed/img/202109111726235.png" alt="Software_framework_diagram"></p><h2 id="3、分类"><a href="#3、分类" class="headerlink" title="3、分类"></a>3、分类</h2><ol><li><p>标准版本</p></li><li><p>nano版本</p><ol><li>是一个极简版的硬实时内核，优C语言开发，采用面向对象的编程思维，具有良好的代码风格，是一款可裁剪的、抢占式实时多任务的RTOS。其内存资源占用极小，功能包括任务处理、软件定时器、信号量、邮箱和实时调度相对完整的实时操作系统特性。</li><li>使用于家电、消费电子、医疗设备、工控等领域大量使用的32位ARM 入门级MCU场合</li><li><img src="https://cdn.jsdelivr.net/gh/TQOQT/picgobed/img/202109111838627.png" alt="架构"></li><li>特点<ol><li>下载简单</li><li>代码简单</li><li>移植简单</li><li>使用简单</li><li>资源占用小</li><li>开源免费</li></ol></li></ol></li><li><p>Smart版本</p><ol><li>基于RT_Thread操作系统衍生的心分支，面向带MMU、中高端应用的芯片、例如arm Cortex_A系列芯片、MIPS芯片、带MMU的RISC-V芯片</li><li>RT_Smart在RT_Thread操作系统的基础上启用独立、完整的进程方式，同时以混合微内核模式执行</li><li>把应用从内核中独立出来，形成独立的用户态应用程序，并具备独立的地址空间</li></ol></li></ol><h1 id="二、RT-Thread移植"><a href="#二、RT-Thread移植" class="headerlink" title="二、RT_Thread移植"></a>二、RT_Thread移植</h1><h2 id="碰见的问题"><a href="#碰见的问题" class="headerlink" title="碰见的问题"></a>碰见的问题</h2><ol><li>用的Nucleo-F103RBT6的开发板，下载时碰见</li></ol><p><img src="https://cdn.jsdelivr.net/gh/TQOQT/picgobed/img/202109122310165.png" alt="image-20210912231006126"></p><p>解决方法：按下载前按住复位，点下载后松开复位按键</p><p>2.选择UART2可打印数据</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define BSP_CLOCK_SOURCE                  ("HSI")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选择内部晶振</p><p>外部是</p><pre class="line-numbers language-none"><code class="language-none">#define BSP_CLOCK_SOURCE                  ("HSE")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define BSP_CLOCK_SOURCE_FREQ_MHZ         ((int32_t)0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>外部晶振频率</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define BSP_CLOCK_SYSTEM_FREQ_MHZ         ((int32_t)72)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>内部晶振频率</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main(void){    //int count = 1;#if 0    while (count++)    {        LOG_D("Hello RT-Thread!");        rt_thread_mdelay(1000);    }#endif    return RT_EOK;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样时，打开xcome输入help可查看数据</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">msh &gt;helpRT-Thread shell commands:clear            - clear the terminal screenversion          - show RT-Thread version informationlist_thread      - list threadlist_sem         - list semaphore in systemlist_event       - list event in systemlist_mutex       - list mutex in systemlist_mailbox     - list mail box in systemlist_msgqueue    - list message queue in systemlist_mempool     - list memory pool in systemlist_timer       - list timer in systemlist_device      - list device in systemhelp             - RT-Thread shell help.ps               - List threads in the system.free             - Show the memory usage in the system.reboot           - Reboot System<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、内核介绍"><a href="#三、内核介绍" class="headerlink" title="三、内核介绍"></a>三、内核介绍</h1><h2 id="内核框架"><a href="#内核框架" class="headerlink" title="内核框架"></a>内核框架</h2><h3 id="1、实时内核"><a href="#1、实时内核" class="headerlink" title="1、实时内核"></a>1、实时内核</h3><p>内核库是为了保障内核能够独立运行的一套小型的类似C库的函数实现子集，这部分根据编译器的不同自带C库的情况也会有些不同，当使用GNUGCC编译器时，会携带更多的标准C库实现</p><p>实时内核的实现包括</p><ol><li><p>对象管理</p></li><li><p>实时调度器</p></li><li><p>线程管理</p></li><li><p>线程间通信</p></li><li><p>时钟管理</p></li><li><p>内存管理</p></li><li><p>设备管理</p><p>内核最小的资源占用情况是3KB ROM，1.2KB RAM</p></li></ol><h3 id="2、线程调度"><a href="#2、线程调度" class="headerlink" title="2、线程调度"></a>2、线程调度</h3><p>​    是本操作系统中最小的调度单位，是基于优先级的全占式多线程调度算法，即在系统中除了中断处理函数、调度器上锁部分的代码和禁止中断的代码时不可抢占的，其他部分都是可以抢占的。包括线程调度器本身。</p><p>​    支持256个线程优先级（可通过配置文件更改为最大支持32个或8个优先级，针对STM32默认配置是32个线程优先级），0表示最高优先级，最低优先级留给空闲线程使用；也支持创建多个具有相同优先级的线程。相同优先级的线程间采用时间片的轮转调度算法进行调度，使每个线程运行相应时间。</p><p>​    调度器在寻找处于就绪状态的具有最高优先级的线程时，所经历的时间是恒定的，系统也不限制线程数量的多少，线程数目只与硬件平台的具体内存相关。</p><h3 id="3、时钟管理"><a href="#3、时钟管理" class="headerlink" title="3、时钟管理"></a>3、时钟管理</h3><ol><li>​    时钟管理以时钟节拍为基础，时钟节拍是本系统最小的时钟单位。</li><li>RT_Thread的定时器提供两类定时器机制<ol><li>单次触发定时器<ol><li>在启动后只会触发一次定时器事件，然后定时器自动停止</li></ol></li><li>周期触发定时器<ol><li>会周期性的触发定时器事件，直到用户手动的停止定时器，否则将永远持续执行下去。</li></ol></li></ol></li></ol><h3 id="4、线程间同步"><a href="#4、线程间同步" class="headerlink" title="4、线程间同步"></a>4、线程间同步</h3><ol><li>​    采用信号量、互斥量与事件集实现线程间同步</li><li>线程通过对信号量、互斥量的获取与释放进行同步</li><li>互斥量采用优先级继承的方式解决了实时系统中常见的优先级翻转问题</li><li>线程同步机制支持线程按优先级等待或按先进先出方式获取信号量或互斥量</li><li>线程通过对事件的发送与接收进行同步</li><li>事件集支持多事件的“或触发”和“与触发”，适合与线程等待多个事件的情况</li></ol><h3 id="5、线程通信"><a href="#5、线程通信" class="headerlink" title="5、线程通信"></a>5、线程通信</h3><ol><li>支持邮箱和消息队列等通信机制。邮箱长度固定为4字节大小</li><li>消息队列能够接收不固定长度的消息，并把消息缓存在自己的内存空间中</li><li>邮箱效率较消息队列更为高效。邮箱和消息队列的发送动作可安全用于中断服务例程中</li><li>通信机制支持线程按优先级等待或按先进先出方式获取</li></ol><h3 id="6、内存管理"><a href="#6、内存管理" class="headerlink" title="6、内存管理"></a>6、内存管理</h3><ol><li>支持静态内存池管理集动态内存堆管理。当静态内存池具有可用内存时，系统对内存块分配的时间将是恒定的。<ol><li>当静态内存池为空时，系统将申请内存块的线程挂起或阻塞掉（即线程等待一段时间后仍为获得内存块就放弃申请并返回，或者立即返回。<strong>等待的时间取决与申请内存块时设置的等待时间参数</strong>），当其他线程释放内存块到内存池时，如果有挂起的待分配内存块的线程存在的话，则系统会将这个线程唤醒</li><li>动态内存堆管理模块在系统资源不同的情况下，分别提供了面向小内存系统的内存管理算法及面向大内存系统的<strong>SLAB内存管理算法</strong><ol><li> 还有一种动态内存堆管理叫做memheap，适用于系统含有多个地址可不连续的内存堆。使用memheap可以将多个内存堆“粘连”在一起，让用户操作先是在操作一个内存堆</li></ol></li></ol></li></ol><h3 id="7、I-O设备管理"><a href="#7、I-O设备管理" class="headerlink" title="7、I/O设备管理"></a>7、I/O设备管理</h3><p>​    将PIN、I2C、SPI、USB、UART等作为外设设备，统一通过设备注册完成。实现了按名称访问的设备管理子系统，可按照统一的API界面访问硬件设备。在设备驱动接口上，根据嵌入式系统的特点，对不同的设备可以挂接相应的事件。当设备事件触发时，由驱动程序通知给上层的应用程序</p><h2 id="内核启动流程"><a href="#内核启动流程" class="headerlink" title="内核启动流程"></a>内核启动流程</h2><p>RT-Thread 支持多种平台和多种编译器，而 rtthread_startup() 函数是 RT-Thread 规定的统一启动入口。一般执行顺序是：系统先从启动文件开始运行，然后进入 RT-Thread 的启动函数 rtthread_startup() ，最后进入用户入口函数 main()，如下图所示：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/TQOQT/picgobed/img/202109162218835.png" alt="启动流程"></p><p> 流程在startup_stm32f10xxb.s中的entry中的rtthread_startup();可以查看到线程流程</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">tid = rt_thread_create("main", main_thread_entry, RT_NULL,                           RT_MAIN_THREAD_STACK_SIZE, RT_MAIN_THREAD_PRIORITY, 20);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>线程名字是main，线程ID是tid，线程执行函数是main_thread_entry，优先级是RT_MAIN_THRED_PRIORITY，栈的大小是RT_MAIN_THREAD_STACK_SIZE，</p><h1 id="四、线程管理"><a href="#四、线程管理" class="headerlink" title="四、线程管理"></a>四、线程管理</h1><ol><li>多任务是通过多线程方式实现，线程是任务的载体，是RTT中最基本的调度单位</li><li>线程执行时的运行环境称为上下文，具体来说就是各种变量和数据，包括所有的寄存器变量、堆栈、内存信息等</li><li>线程在运行的时候，它会认为自己独占CPU运行 </li></ol><h2 id="4-1、线程管理特点"><a href="#4-1、线程管理特点" class="headerlink" title="4.1、线程管理特点"></a>4.1、线程管理特点</h2><p>主要功能时对线程进行管理和调度，系统中总共存在两类线程，分别时<strong>系统线程</strong>和<strong>用户线程</strong>，重点放在用户线程</p><ol><li>系统线程时由RT_Thread内核创建的线程</li><li>用户线程是由应用程序创建的线程</li></ol><p>两类线程都会从内核对象容器中分配线程对象，当线程被删除时，也会被从对象容器中删除。</p><h2 id="4-2、线程工作机制"><a href="#4-2、线程工作机制" class="headerlink" title="4.2、线程工作机制"></a>4.2、线程工作机制</h2><h3 id="4-2-1、线程控制块"><a href="#4-2-1、线程控制块" class="headerlink" title="4.2.1、线程控制块"></a>4.2.1、线程控制块</h3><p>线程控制块由结构体struct rt_thread表示，是管理线程的一个数据结构，会存放线程的一些信息，例如优先级、线程名称、线程状态，也包含线程与线程之间连接用的链表结构，线程等待事件集合</p><p> <strong><em>cleanup函数指针指向的函数，会在线程退出的时候，被idle线程回调一次，执行用户设置的清理现场等工作</em></strong></p><h3 id="4-2-2、线程属性"><a href="#4-2-2、线程属性" class="headerlink" title="4.2.2、线程属性"></a>4.2.2、线程属性</h3><ol><li>线程栈<ol><li>RT_Thread线程具有独立的栈，当进行线程切换时，会将当前线程的上下文存在栈中，当线程要恢复运行时，再从栈中读取上下文信息，进行恢复</li></ol></li><li>线程状态</li></ol><p><img src="https://cdn.jsdelivr.net/gh/TQOQT/picgobed/img/202110272039860.png" alt="image-20211027203924158"></p><ol><li>线程优先级<ol><li>最大支持256个线程优先级，数值越小优先级越高，0为最高优先级。资源紧张的系统中，可根据实际情况选择只支持8个或32个优先级的系统配置。</li><li>Cortex-M系列中普遍采用32个优先级，最低优先级默认分配给空闲线程（<strong>idle</strong>）使用，用户一般不使用。在系统中，当有比当前线程优先级更高的线程就绪时，当前线程将立刻被换出，高优先级线程抢占处理器运行</li></ol></li><li>时间片<ol><li>每个线程都有时间片这个参数，但时间片仅对优先级相同的就绪态线程有效</li></ol></li></ol><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h4><p>​    如果一个线程中程序陷入死循环操作，则比它优先级低的线程都不能执行，所以在实时操作系统中必须注意：线程中不能陷入死循环操作，必须要有让出CPU使用权的动作，<u><strong>如循环中调用延时函数（进入挂起状态）或主动挂起</strong></u></p><h3 id="4-2-3、线程状态之间切换"><a href="#4-2-3、线程状态之间切换" class="headerlink" title="4.2.3、线程状态之间切换"></a>4.2.3、线程状态之间切换</h3><p><img src="https://cdn.jsdelivr.net/gh/TQOQT/picgobed/img/202110280949649.png" alt="线程状态转换图"></p><h3 id="4-2-4、系统线程"><a href="#4-2-4、系统线程" class="headerlink" title="4.2.4、系统线程"></a>4.2.4、系统线程</h3><p>RT_Thread内核中的系统线程有空闲线程和主线程</p><h2 id="4-3、线程相关操作"><a href="#4-3、线程相关操作" class="headerlink" title="4.3、线程相关操作"></a>4.3、线程相关操作</h2><p>创建/初始化、启动、运行、删除/脱离。</p><p>动态线程：是系统自动从动态内存堆上分配空间和线程句柄（初始化heap之后才能使用create创建动态线程）</p><p>静态线程：由用户分配栈空间与线程句柄</p><p><img src="https://cdn.jsdelivr.net/gh/TQOQT/picgobed/img/202110280957492.png"></p><h3 id="4-3-1、动态线程"><a href="#4-3-1、动态线程" class="headerlink" title="4.3.1、动态线程"></a>4.3.1、动态线程</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">rt_thread_t th1_ptr = NULL; //结构体变量接收返回值void th_entry(void *parameter){    while(1){        rt_kprintf("th_entry running...\n");        rt_thread_mdelay(1000);    }}int main(void){    //函数名称    //入口函数    //给线程入口函数传参    //线程栈的大小    //优先级    //系统滴答时间    th1_ptr = rt_thread_create("th_demo",                                th_entry,                                NULL,1024,                                 20,                                 5);    if (th1_ptr == RT_NULL) {        LOG_E("rt_thread_create failed...\n");    }    LOG_D("rt_thread_create successed...\n");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C"> \ | /- RT -     Thread Operating System / | \     4.0.3 build Oct 28 2021 2006 - 2020 Copyright by rt-thread team[0m[D/main] rt_thread_create successed...[0mmsh &gt;helpRT-Thread shell commands:clear            - clear the terminal screenversion          - show RT-Thread version informationlist_thread      - list threadlist_sem         - list semaphore in systemlist_event       - list event in systemlist_mutex       - list mutex in systemlist_mailbox     - list mail box in systemlist_msgqueue    - list message queue in systemlist_mempool     - list memory pool in systemlist_timer       - list timer in systemlist_device      - list device in systemhelp             - RT-Thread shell help.ps               - List threads in the system.free             - Show the memory usage in the system.reboot           - Reboot Systemmsh &gt;list_threadthread   pri  status      sp     stack size max used left tick  error-------- ---  ------- ---------- ----------  ------  ---------- ---th_demo   20  init    0x00000040 0x00000400    06%   0x00000005 000tshell    20  running 0x000000c8 0x00001000    14%   0x0000000a 000tidle0    31  ready   0x00000070 0x00000100    57%   0x0000000c 000timer      4  suspend 0x0000007c 0x00000200    24%   0x00000009 000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序下载进去后，复位就可以看到打印出来的字符串，help查看命令，list_thread查看有哪些线程</p><p>rt_thread_create（”线程名称“，入口函数，线程入口函数的传参，线程栈的大小，优先级，系统滴答时间）</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">rt_thread_t th1_ptr = NULL; //结构体变量接收返回值void th_entry(void *parameter){    while(1){        rt_kprintf("th_entry running...\n");        rt_thread_mdelay(1000);    }}int main(void){    //函数名称    //入口函数    //给线程入口函数传参    //线程栈的大小    //优先级    //系统滴答时间    th1_ptr = rt_thread_create("th_demo",                                th_entry,                                NULL,1024,                                 20,                                 5);    if (th1_ptr == RT_NULL) {        LOG_E("rt_thread_create failed...\n");        return RT_ENOMEM;    }    LOG_D("rt_thread_create successed...\n");    rt_thread_startup(th1_ptr);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C"> \ | /- RT -     Thread Operating System / | \     4.0.3 build Oct 28 2021 2006 - 2020 Copyright by rt-thread team[0m[D/main] rt_thread_create successed...[0mmsh &gt;th_entry running...th_entry running...th_entry running...list_threadthread   pri  status      sp     stack size max used left tick  error-------- ---  ------- ---------- ----------  ------  ---------- ---th_demo   20  suspend 0x000000a8 0x00000400    20%   0x00000005 000tshell    20  running 0x000000c8 0x00001000    14%   0x00000004 000tidle0    31  ready   0x00000070 0x00000100    57%   0x00000002 000timer      4  suspend 0x0000007c 0x00000200    24%   0x00000009 000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为打印th_entry running…时间是非常短的，大部分时间是在mdelay上，所以是处以挂起状态</p><p>rt_thread_startup（线程创建后赋值的）</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>name</td><td>线程的名称；线程名称的最大长度由 rtconfig.h 中的宏 RT_NAME_MAX 指定，多余部分会被自动截掉</td></tr><tr><td>entry</td><td>线程入口函数</td></tr><tr><td>parameter</td><td>线程入口函数参数</td></tr><tr><td>stack_size</td><td>线程栈大小，单位是字节</td></tr><tr><td>priority</td><td>线程的优先级。优先级范围根据系统配置情况（rtconfig.h 中的 RT_THREAD_PRIORITY_MAX 宏定义），如果支持的是 256 级优先级，那么范围是从 0~255，数值越小优先级越高，0 代表最高优先级</td></tr><tr><td>tick</td><td>线程的时间片大小。时间片（tick）的单位是操作系统的时钟节拍。当系统中存在相同优先级线程时，这个参数指定线程一次调度能够运行的最大时间长度。这个时间片运行结束时，调度器自动选择下一个就绪态的同优先级线程进行运行</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>thread</td><td>线程创建成功，返回线程句柄</td></tr><tr><td>RT_NULL</td><td>线程创建失败</td></tr></tbody></table><p>对于一些使用 rt_thread_create() 创建出来的线程，当不需要使用，或者运行出错时，我们可以使用下面的函数接口来从系统中把线程完全删除掉：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">rt_err_t <span class="token function">rt_thread_delete</span><span class="token punctuation">(</span>rt_thread_t thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>调用该函数后，线程对象将会被移出线程队列并且从内核对象管理器中删除，线程占用的堆栈空间也会被释放，收回的空间将重新用于其他的内存分配。实际上，用 rt_thread_delete() 函数删除线程接口，仅仅是把相应的线程状态更改为 RT_THREAD_CLOSE 状态，然后放入到 rt_thread_defunct 队列中；而真正的删除动作（释放线程控制块和释放线程栈）需要到下一次执行空闲线程时，由空闲线程完成最后的线程删除动作。线程删除 rt_thread_delete() 接口的参数和返回值见下表：</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>要删除的线程句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>删除线程成功</td></tr><tr><td>-RT_ERROR</td><td>删除线程失败</td></tr></tbody></table><h3 id="4-3-2、启动线程"><a href="#4-3-2、启动线程" class="headerlink" title="4.3.2、启动线程"></a>4.3.2、启动线程</h3><p>创建（初始化）的线程状态处于初始状态，并未进入就绪线程的调度队列，我们可以在线程初始化 / 创建成功后调用下面的函数接口让该线程进入就绪态：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">rt_err_t <span class="token function">rt_thread_startup</span><span class="token punctuation">(</span>rt_thread_t thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当调用这个函数时，将把线程的状态更改为就绪状态，并放到相应优先级队列中等待调度。如果新启动的线程优先级比当前线程优先级高，将立刻切换到这个线程。线程启动接口 rt_thread_startup() 的参数和返回值见下表：</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>线程句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>线程启动成功</td></tr><tr><td>-RT_ERROR</td><td>线程启动失败</td></tr></tbody></table><h3 id="4-3-3、静态线程"><a href="#4-3-3、静态线程" class="headerlink" title="4.3.3、静态线程"></a>4.3.3、静态线程</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">rt_thread_t th1_ptr = NULL; //结构体变量接收返回值struct rt_thread th2;rt_uint8_t th_2_stack[512] = {0};void th1_entry(void *parameter){    while(1){        rt_kprintf("th1_entry running...\n");        rt_thread_mdelay(1000);    }}void th2_entry(void *parameter){    int i = 0;    for (i = 0; i &lt; 10; i++) {        rt_kprintf("th2_entry running...\n");//        rt_thread_mdelay(1000);    }}int main(void){    int ret = 0;    //动态线程创建-&gt;函数名称、入口函数、给线程入口函数传参、线程栈的大小、优先级、系统滴答时间    th1_ptr = rt_thread_create("th1_demo",th1_entry,NULL,1024,20,5);    if (th1_ptr == RT_NULL) {        LOG_E("rt_thread_create failed...\n");        return RT_ENOMEM;    }    LOG_D("rt_thread_create succeed...\n");    rt_thread_startup(th1_ptr);    //静态线程初始化-&gt;线程对象、函数名称、入口函数、入口函数参数、线程栈起始地址、线程栈大小、优先级、系统滴答时间    ret = rt_thread_init(&amp;th2, "th2_demo", th2_entry , NULL, th_2_stack, sizeof(th_2_stack), 19, 5);    if (ret &lt; 0) {        LOG_E("rt_thread_init failed...\n");        return ret;    }    LOG_D("rt_thread_init succeed...\n");    rt_thread_startup(&amp;th2);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C"> \ | /- RT -     Thread Operating System / | \     4.0.3 build Oct 28 2021 2006 - 2020 Copyright by rt-thread team[0m[D/main] rt_thread_create succeed...[0m[0m[D/main] rt_thread_init succeed...[0mth2_entry running...th2_entry running...th2_entry running...th2_entry running...th2_entry running...th2_entry running...th2_entry running...th2_entry running...th2_entry running...th2_entry running...msh &gt;th1_entry running...th1_entry running...th1_entry running...th1_entry running...th1_entry running...th1_entry running...th1_entry running...th1_entry running...th1_entry running...th1_entry running...th1_entry running...th1_entry running...th1_entry running...th1_entry running...th1_entry running...th1_entry running...th1_entry running...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注释th2_entry中的延时，则由于静态初始化的优先级更高会先打印十次，后面全部只会打印动态线程</p><p>静态线程的线程句柄（或者说线程控制块指针）、线程栈由用户提供。静态线程是指线程控制块、线程运行栈一般都设置为全局变量，在编译时就被确定、被分配处理，内核不负责动态分配内存空间。需要注意的是，用户提供的栈首地址需做系统对齐（例如 ARM 上需要做 4 字节对齐）。线程初始化接口 rt_thread_init() 的参数和返回值见下表：</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>线程句柄。线程句柄由用户提供出来，并指向对应的线程控制块内存地址</td></tr><tr><td>name</td><td>线程的名称；线程名称的最大长度由 rtconfig.h 中定义的 RT_NAME_MAX 宏指定，多余部分会被自动截掉</td></tr><tr><td>entry</td><td>线程入口函数</td></tr><tr><td>parameter</td><td>线程入口函数参数</td></tr><tr><td>stack_start</td><td>线程栈起始地址</td></tr><tr><td>stack_size</td><td>线程栈大小，单位是字节。在大多数系统中需要做栈空间地址对齐（例如 ARM 体系结构中需要向 4 字节地址对齐）</td></tr><tr><td>priority</td><td>线程的优先级。优先级范围根据系统配置情况（rtconfig.h 中的 RT_THREAD_PRIORITY_MAX 宏定义），如果支持的是 256 级优先级，那么范围是从 0 ～ 255，数值越小优先级越高，0 代表最高优先级</td></tr><tr><td>tick</td><td>线程的时间片大小。时间片（tick）的单位是操作系统的时钟节拍。当系统中存在相同优先级线程时，这个参数指定线程一次调度能够运行的最大时间长度。这个时间片运行结束时，调度器自动选择下一个就绪态的同优先级线程进行运行</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>线程创建成功</td></tr><tr><td>-RT_ERROR</td><td>线程创建失败</td></tr></tbody></table><p>对于用 rt_thread_init() 初始化的线程，使用 rt_thread_detach() 将使线程对象在线程队列和内核对象管理器中被脱离。线程脱离函数如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">rt_err_t <span class="token function">rt_thread_detach</span> <span class="token punctuation">(</span>rt_thread_t thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>线程脱离接口 rt_thread_detach() 的参数和返回值见下表：</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>线程句柄，它应该是由 rt_thread_init 进行初始化的线程句柄。</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>线程脱离成功</td></tr><tr><td>-RT_ERROR</td><td>线程脱离失败</td></tr></tbody></table><p>这个函数接口是和 rt_thread_delete() 函数相对应的， rt_thread_delete() 函数操作的对象是 rt_thread_create() 创建的句柄，而 rt_thread_detach() 函数操作的对象是使用 rt_thread_init() 函数初始化的线程控制块。同样，线程本身不应调用这个接口脱离线程本身。</p><p><em><u><strong>空闲线程是一个线程状态永远为就绪态的线程，因此设置的钩子函数必须保证空闲线程在任何时刻都不会处于挂起状态，如rt_thread_delay()、rt_thread_take()等可能会导致线程挂起的函数都不能使用</strong></u></em></p><h3 id="4-3-4、钩子函数"><a href="#4-3-4、钩子函数" class="headerlink" title="4.3.4、钩子函数"></a>4.3.4、钩子函数</h3><p>在整个系统的运行时，系统都处于线程运行、中断触发 - 响应中断、切换到其他线程，甚至是线程间的切换过程中，或者说系统的上下文切换是系统中最普遍的事件。有时用户可能会想知道在一个时刻发生了什么样的线程切换，可以通过调用下面的函数接口设置一个相应的钩子函数。在系统线程切换时，这个钩子函数将被调用：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">rt_scheduler_sethook</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>hook<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rt_thread</span><span class="token operator">*</span> from<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rt_thread</span><span class="token operator">*</span> to<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>复制错误复制成功<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置调度器钩子函数的输入参数如下表所示：</p><table><thead><tr><th><strong>函数参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>hook</td><td>表示用户定义的钩子函数指针</td></tr></tbody></table><p>钩子函数 hook() 的声明如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">hook</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rt_thread</span><span class="token operator">*</span> from<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rt_thread</span><span class="token operator">*</span> to<span class="token punctuation">)</span><span class="token punctuation">;</span>复制错误复制成功<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>调度器钩子函数 hook() 的输入参数如下表所示：</p><table><thead><tr><th><strong>函数参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>from</td><td>表示系统所要切换出的线程控制块指针</td></tr><tr><td>to</td><td>表示系统所要切换到的线程控制块指针</td></tr></tbody></table><p>注：请仔细编写你的钩子函数，稍有不慎将很可能导致整个系统运行不正常（在这个钩子函数中，基本上不允许调用系统 API，更不应该导致当前运行的上下文挂起）。</p><h3 id="4-3-5、设置调度器hook函数"><a href="#4-3-5、设置调度器hook函数" class="headerlink" title="4.3.5、设置调度器hook函数"></a>4.3.5、设置调度器hook函数</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">rt_thread_t th1_ptr = NULL; //结构体变量接收返回值struct rt_thread th2;rt_uint8_t th_2_stack[512] = {0};void th1_entry(void *parameter){    int i = 0;    for (i = 0; i &lt; 5; ++i) {        rt_kprintf("th1_entry running...\n");        rt_thread_mdelay(1000);    }}void th2_entry(void *parameter){    int i = 0;    for (i = 0; i &lt; 5; i++) {        rt_kprintf("th2_entry running...\n");        rt_thread_mdelay(1000);    }}void scheduler_hook(struct rt_thread *from, struct rt_thread *to){    rt_kprintf("from:%s ---&gt; to:%s\n",from-&gt;name,to-&gt;name);}int main(void){    int ret = 0;    rt_scheduler_sethook(scheduler_hook);    //动态线程创建-&gt;函数名称、入口函数、给线程入口函数传参、线程栈的大小、优先级、系统滴答时间    th1_ptr = rt_thread_create("th1_demo",th1_entry,NULL,1024,20,5);    if (th1_ptr == RT_NULL) {        LOG_E("rt_thread_create failed...\n");        return -RT_ENOMEM;    }    LOG_D("rt_thread_create succeed...\n");    rt_thread_startup(th1_ptr);    //静态线程初始化-&gt;线程对象、函数名称、入口函数、入口函数参数、线程栈起始地址、线程栈大小、优先级、系统滴答时间    ret = rt_thread_init(&amp;th2, "th2_demo", th2_entry , NULL, th_2_stack, sizeof(th_2_stack), 19, 5);    if (ret &lt; 0) {        LOG_E("rt_thread_init failed...\n");        return ret;    }    LOG_D("rt_thread_init succeed...\n");    rt_thread_startup(&amp;th2);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C"> \ | /- RT -     Thread Operating System / | \     4.0.3 build Oct 28 2021 2006 - 2020 Copyright by rt-thread team[0m[D/main] rt_thread_create succeed...[0m[0m[D/main] rt_thread_init succeed...[0mfrom:main ---&gt; to:th2_demo?th2_entry running...from:th2_demo? ---&gt; to:tshellmsh &gt;from:tshell ---&gt; to:th1_demoth1_entry running...from:th1_demo ---&gt; to:tidle0from:tidle0 ---&gt; to:th2_demo?th2_entry running...from:th2_demo? ---&gt; to:tidle0from:tidle0 ---&gt; to:th1_demoth1_entry running...from:th1_demo ---&gt; to:tidle0from:tidle0 ---&gt; to:th2_demo?th2_entry running...from:th2_demo? ---&gt; to:tidle0from:tidle0 ---&gt; to:th1_demoth1_entry running...from:th1_demo ---&gt; to:tidle0from:tidle0 ---&gt; to:th2_demo?th2_entry running...from:th2_demo? ---&gt; to:tidle0from:tidle0 ---&gt; to:th1_demoth1_entry running...from:th1_demo ---&gt; to:tidle0from:tidle0 ---&gt; to:th2_demo?th2_entry running...from:th2_demo? ---&gt; to:tidle0from:tidle0 ---&gt; to:th1_demoth1_entry running...from:th1_demo ---&gt; to:tidle0from:tidle0 ---&gt; to:th2_demo?from:th2_demo ---&gt; to:tidle0from:tidle0 ---&gt; to:th1_demofrom:th1_demo ---&gt; to:tidle0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="五、时钟管理"><a href="#五、时钟管理" class="headerlink" title="五、时钟管理"></a>五、时钟管理</h1><p>操作系统需要通过<strong>时间</strong>来规范其<strong>任务</strong></p><h2 id="5-1、时钟节拍"><a href="#5-1、时钟节拍" class="headerlink" title="5.1、时钟节拍"></a>5.1、时钟节拍</h2><p>时钟节拍的长度可以根据RT_TICK_PER_SECOND的定义来调整。rtconfig.h配置文件中定义</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">/**频率是1000hz周期是1/1000ms*所以节拍是1ms*/#define RT_TICK_PER_SECOND 1000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>系统滴答定时器中断处理函数（每1ms触发一次systick定时器中断）</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">/** * This is the timer interrupt service routine. *这是定时器中断服务程序 */void SysTick_Handler(void){    /* enter interrupt */    rt_interrupt_enter();    HAL_IncTick();    rt_tick_increase();//++rt_tick;全局变量自加，记录的是系统从启动到现在的时间节拍数    /* leave interrupt */    rt_interrupt_leave();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-2、获取系统节拍"><a href="#5-2、获取系统节拍" class="headerlink" title="5.2、获取系统节拍"></a>5.2、获取系统节拍</h2><h3 id="5-2-1、获取系统计数函数"><a href="#5-2-1、获取系统计数函数" class="headerlink" title="5.2.1、获取系统计数函数"></a>5.2.1、获取系统计数函数</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">/** * This function will return current tick from operating system startup * * @return current tick */rt_tick_t rt_tick_get(void){    /* return the global tick */    return rt_tick;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main(void){    int i = 0;    rt_tick_t tick = 0;    for (i = 0; i &lt; 10; ++i) {        tick = rt_tick_get();        rt_kprintf("tick:%u\n",tick);        rt_thread_mdelay(500);//休眠500ms    }    return RT_EOK;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以打印出时钟节拍</p><h2 id="5-3、定时器"><a href="#5-3、定时器" class="headerlink" title="5.3、定时器"></a>5.3、定时器</h2><p>定时器，是指从指定的时刻开始，经过一定的指定时间后触发一个事件，例如定个时间提醒第二天能够按时起床。定时器有<strong>硬件定时器</strong>和<strong>软件定时器</strong>之分：</p><p>1）<strong>硬件定时器</strong>是芯片本身提供的定时功能。一般是由外部晶振提供给芯片输入时钟，芯片向软件模块提供一组配置寄存器，接受控制输入，到达设定时间值后芯片中断控制器产生时钟中断。硬件定时器的精度一般很高，可以达到纳秒级别，并且是中断触发方式。</p><p>2）<strong>软件定时器</strong>是由操作系统提供的一类系统接口，它构建在硬件定时器基础之上，使系统能够提供不受数目限制的定时器服务。</p><p>RT-Thread 操作系统提供软件实现的定时器，以时钟节拍（OS Tick）的时间长度为单位，即定时数值必须是 OS Tick 的整数倍，例如一个 OS Tick 是 10ms，那么上层软件定时器只能是 10ms，20ms，100ms 等，而不能定时为 15ms。RT-Thread 的定时器也基于系统的节拍，提供了基于节拍整数倍的定时能力。</p><p><strong>HSE</strong>：外部时钟</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="操作系统" scheme="https://tqoqt.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="keil" scheme="https://tqoqt.github.io/tags/keil/"/>
    
    <category term="RT_Thread" scheme="https://tqoqt.github.io/tags/RT-Thread/"/>
    
  </entry>
  
  <entry>
    <title>keil等的开发环境</title>
    <link href="https://tqoqt.github.io/posts/keil1.html"/>
    <id>https://tqoqt.github.io/posts/keil1.html</id>
    <published>2021-09-06T16:00:00.000Z</published>
    <updated>2021-09-21T13:49:54.284Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>  相信大部分人在设置开发环境时都会碰到很多问题。则写这个博客记录一些开发软件下载链接</p><p>IDM下载贼快</p><p>链接：<a href="https://pan.baidu.com/s/1uu5FGYhsk6frsCgq3HNKQg">https://pan.baidu.com/s/1uu5FGYhsk6frsCgq3HNKQg</a><br>提取码：1234</p><p>按要求安装后，在浏览器安装插件，再安装一个IDM，可以下载巨快，安装其他插件也可无限制的下载百度网盘</p><h2 id="Keil下载"><a href="#Keil下载" class="headerlink" title="Keil下载"></a>Keil下载</h2><p>// -date:  2019-11-20<br>// -time:  0:18 最新：MDK5.29版本<br><a href="https://armkeil.blob.core.windows.net/eval/MDK529.EXE">https://armkeil.blob.core.windows.net/eval/MDK529.EXE</a><br>// -date:  2019-06-10<br>// -time:  0:1<br>最新：MDK5.28A版本下载<br><a href="https://armkeil.blob.core.windows.net/eval/MDK528.EXE">https://armkeil.blob.core.windows.net/eval/MDK528.EXE</a><br>// -date:  2019-1-11<br>// -time:  0:18<br>最新：MDK5.27Pre版本下载<br><a href="https://armkeil.blob.core.windows.net/eval/MDK527pre.EXE">https://armkeil.blob.core.windows.net/eval/MDK527pre.EXE</a><br>// -date:  2018-09-11<br>// -time:  0:18</p><p>最新：MDK5.26版本下载<br><a href="https://armkeil.blob.core.windows.net/eval/MDK526.EXE">https://armkeil.blob.core.windows.net/eval/MDK526.EXE</a></p><h2 id="STM32CubeMX"><a href="#STM32CubeMX" class="headerlink" title="STM32CubeMX"></a>STM32CubeMX</h2><p><a href="https://www.st.com/zh/development-tools/stm32cubemx.html">STM32CubeMX - STM32Cube初始化代码生成器 - STMicroelectronics</a></p><h2 id="画板工具"><a href="#画板工具" class="headerlink" title="画板工具"></a>画板工具</h2><h3 id="立创EDA"><a href="#立创EDA" class="headerlink" title="立创ＥＤＡ"></a>立创ＥＤＡ</h3><p><a href="https://image.lceda.cn/files/lceda-windows-x64-6.4.23.exe">https://image.lceda.cn/files/lceda-windows-x64-6.4.23.exe</a></p><h3 id="嘉立创打板工具"><a href="#嘉立创打板工具" class="headerlink" title="嘉立创打板工具"></a>嘉立创打板工具</h3><p><a href="https://download.jlc.com/jlchelper/release/3.4.4/JLCPcAssit_setup_3.4.4.zip">https://download.jlc.com/jlchelper/release/3.4.4/JLCPcAssit_setup_3.4.4.zip</a></p><h2 id="PicGo"><a href="#PicGo" class="headerlink" title="ＰｉｃＧｏ"></a>ＰｉｃＧｏ</h2><p><a href="https://github-releases.githubusercontent.com/113965016/c12415ff-1328-4668-b8b1-df91177cb077?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAIWNJYAX4CSVEH53A/20210907/us-east-1/s3/aws4_request&amp;X-Amz-Date=20210907T145427Z&amp;X-Amz-Expires=300&amp;X-Amz-Signature=0bbfca0b314cbe6fc1b8fd71e73181b9d47774c7131bfe2419c2d9803192aa83&amp;X-Amz-SignedHeaders=host&amp;actor_id=84925708&amp;key_id=0&amp;repo_id=113965016&amp;response-content-disposition=attachment;%20filename=PicGo-Setup-2.3.0-beta.8-x64.exe&amp;response-content-type=application/octet-stream">https://github-releases.githubusercontent.com/113965016/c12415ff-1328-4668-b8b1-df91177cb077?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20210907%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20210907T145427Z&amp;X-Amz-Expires=300&amp;X-Amz-Signature=0bbfca0b314cbe6fc1b8fd71e73181b9d47774c7131bfe2419c2d9803192aa83&amp;X-Amz-SignedHeaders=host&amp;actor_id=84925708&amp;key_id=0&amp;repo_id=113965016&amp;response-content-disposition=attachment%3B%20filename%3DPicGo-Setup-2.3.0-beta.8-x64.exe&amp;response-content-type=application%2Foctet-stream</a></p><h2 id="VSCode"><a href="#VSCode" class="headerlink" title="ＶＳＣｏｄｅ"></a>ＶＳＣｏｄｅ</h2><p><a href="https://az764295.vo.msecnd.net/stable/e7d7e9a9348e6a8cc8c03f877d39cb72e5dfb1ff/VSCodeUserSetup-x64-1.60.0.exe">https://az764295.vo.msecnd.net/stable/e7d7e9a9348e6a8cc8c03f877d39cb72e5dfb1ff/VSCodeUserSetup-x64-1.60.0.exe</a></p><h2 id="万兴PDF破解版可免费转换各种文件"><a href="#万兴PDF破解版可免费转换各种文件" class="headerlink" title="万兴PDF破解版可免费转换各种文件"></a>万兴PDF破解版可免费转换各种文件</h2><p>链接：<a href="https://pan.baidu.com/s/1DeuXZabHEa2fzO5uViJ_xg">https://pan.baidu.com/s/1DeuXZabHEa2fzO5uViJ_xg</a><br>提取码：1234</p><h2 id="Offic破解版，可安装任意的文件"><a href="#Offic破解版，可安装任意的文件" class="headerlink" title="Ｏｆｆｉｃ破解版，可安装任意的文件"></a>Ｏｆｆｉｃ破解版，可安装任意的文件</h2><p>链接：<a href="https://pan.baidu.com/s/1_JbUy3teCUDlwC5iRgWwsw">https://pan.baidu.com/s/1_JbUy3teCUDlwC5iRgWwsw</a><br>提取码：1234</p><h2 id="STM开发问题"><a href="#STM开发问题" class="headerlink" title="STM开发问题"></a>STM开发问题</h2><p>突然不能下载程序</p><p>swd/jtag communication failure</p><p>发现这个问题</p><p>则</p><p>将板子供电全部断开，这里包括3.3V电源供电和JLINK等所有能给开发板供上电的设备全断开<br>2，找到BOOT0引脚，将BOOT0拉高。<br>  方法：在板子上找一个高电平引脚，手动用导线将BOOT0连接到该引脚上即可。<br>  注意：我的STM32板子供电是3.3V的，所以我找了一个3.3V的引脚，用导线连接到了BOOT0上，千万别弄错了，电平接高了不小心可是要烧坏板子的！<br>3，BOOT0拉高以后，保持这个姿势不要动，打开电源，重新给板子上电<br>4，插上JLink或者STLink ，下载程序。</p><p>一般这次肯定可以下载进去了。下载完成以后，就可以断开BOOT0了，让他恢复低电平。<br>好到这里就全部完成了，板子肯定也回复正常了，继续嗨吧。</p><p>上述方法原因解释开板默认JTAG和SWD接口都是打开的，BOOT0是低电平，当把BOOT0置高时，给板子上电，板子启动的时候程序会卡住，也就是内部闪光的程序并未执行，这个时候SW和JTAD接口都是出于默认打开的状态。然后下载一个不关闭JTAG或者SW接口的程序，覆盖之前闪存中的程序就好了。</p><p>所以先将板子供电全部断开（这里包括3.3V电源供电和JLINK等所有能给开发板供上电的设备全断开），再将开发板的BOOT0拉高，重新给开发板上电，把程序中关闭JTAG或者SW的程序删掉，然后下载到开发板中，程序下载完成就好了。</p><p>SWD和JTAG被关闭原因正搞板子发现程序下载不进去了，到处查找原因，发现自己在程序中不小心把STM32的SWD和JTAD接口都给关了，如下就是关掉这两个接口的两句程序：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="开发环境篇" scheme="https://tqoqt.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%AF%87/"/>
    
    
    <category term="STM32CubeMX" scheme="https://tqoqt.github.io/tags/STM32CubeMX/"/>
    
    <category term="keil" scheme="https://tqoqt.github.io/tags/keil/"/>
    
  </entry>
  
  <entry>
    <title>Git使用</title>
    <link href="https://tqoqt.github.io/posts/git.html"/>
    <id>https://tqoqt.github.io/posts/git.html</id>
    <published>2021-09-06T16:00:00.000Z</published>
    <updated>2021-09-10T16:07:14.128Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="git简介"><a href="#git简介" class="headerlink" title="git简介"></a>git简介</h2><p>Git有三大区（工作-Untracked、暂存-Unstaged、版本-Uncommited）</p><h2 id="1-版本控制"><a href="#1-版本控制" class="headerlink" title="1.版本控制"></a>1.版本控制</h2><h3 id="本地版本控制"><a href="#本地版本控制" class="headerlink" title="本地版本控制"></a>本地版本控制</h3><p>个人使用本地存储</p><h3 id="集中版本控制"><a href="#集中版本控制" class="headerlink" title="集中版本控制"></a>集中版本控制</h3><p>存储到服务器中，使用完上传到服务器中，需要时从服务器下载，有服务器奔溃风险</p><h3 id="分布式版本控制"><a href="#分布式版本控制" class="headerlink" title="分布式版本控制"></a>分布式版本控制</h3><p>每个人拥有全部代码，可以存储在本地，有网时上传到服务器中</p><h2 id="2-git和SVN的区别"><a href="#2-git和SVN的区别" class="headerlink" title="2.git和SVN的区别"></a>2.git和SVN的区别</h2><p>SVN是集中式版本控制系统，版本库集中放在服务器中，工作时从服务器更新到最新版本，完成工作后上传到服务器中，必须联网，对网络带宽要求高</p><p>git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作时不需联网，协同时，两人互相把修改的部分推送给对方，就可以看到对方的修改。可以看到对方修改了那些代码和文件</p><h2 id="3-git命令"><a href="#3-git命令" class="headerlink" title="3.git命令"></a>3.git命令</h2><p>1.cd ..    回到文件上一级</p><p>2.cd xx    到xx文件夹中</p><p>3.pwd    显示当前目录</p><p>4.clear    清屏</p><p>5、ls    列出当前文件夹中的文件</p><p>6、touch index.js    新建一个index.js文件</p><p>7、rm index.js    移除一个index.js文件</p><p>8、mkdir test    新建一个test文件夹</p><p>9、rm -r test    删除掉test文件夹</p><p>10、mv index.html test    把index.html文件移动到test文件夹中（在命令行中的文件）</p><p>11、reset    重新初始化终端/清屏</p><p>12、history    查看命令历史</p><p>13、help    帮助</p><p>14、exit    退出</p><p>15、#    注释</p><h2 id="4、Git配置"><a href="#4、Git配置" class="headerlink" title="4、Git配置"></a>4、Git配置</h2><p>1、git config –global –list    查看配置的用户名和邮箱</p><p>2、git config –global user.name “xx”    设置用户名</p><p>3、gitconfig –global user.email “xx”    设置用户邮箱</p><h2 id="5、工作原理"><a href="#5、工作原理" class="headerlink" title="5、工作原理"></a>5、工作原理</h2><ol><li><p>git本地有三个工作区，工作目录（working Directory)、暂存区（Stage/index）、资源库（Repository或git Directiory），加上远程的git仓库（Remote Directory）</p><p>​                            </p><table><thead><tr><th align="center">git push（上传到服务）</th><th align="center">Remote Directory（远程仓库）</th><th align="center"></th></tr></thead><tbody><tr><td align="center">git commit（提交修改）</td><td align="center">History（本地git仓库）</td><td align="center">git pull（从服务器下拉代码）</td></tr><tr><td align="center">git add files（添加文件）</td><td align="center">Stage（index）（暂存区）</td><td align="center">git reset（上一个版本）</td></tr><tr><td align="center"></td><td align="center">Working Directory（本地文件）</td><td align="center">git checkout（切换本地分支）</td></tr></tbody></table><p>​            </p><p>​                                        <img src="file:///F:\QQ\2094668015\Image\Group2\PX\J8\PXJ8XDLZ[`OMJSO@7]J_%[N.jpg" alt="img"></p><p>​                                            </p><p>​    git clone 网址，克隆网址东西</p></li></ol><h2 id="6、git文件操作"><a href="#6、git文件操作" class="headerlink" title="6、git文件操作"></a>6、git文件操作</h2><p><img src="C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20210818150923660.png" alt="image-20210818150923660"></p><h2 id="7、git的基本操作"><a href="#7、git的基本操作" class="headerlink" title="7、git的基本操作"></a>7、git的基本操作</h2><p>1、git add .    添加所有文件提交到暂存区</p><p>2、git status    查看所有文件的状态</p><p>3、git commit -m “new file hello.txt”    提交暂存区的文件到本地仓库    -m “xx”提交信息</p><p>4、忽略文件</p><p>​    #.txt    #忽略所有的.txt文件，.txt结尾的文件不会上传</p><p>​    ！lib.txt    #但lib.txt文件除外</p><p>​    /temp    #仅忽略项目根目录下的TODO文件，不包括其他目录temp</p><p>​    build/    #忽略build/目录下的所有文件    （/在前面往上忽略，在后面往下忽略）</p><p>​    doc/*.txt    #会忽略doc/notes.txt,但不包括doc/server/arch.txt</p><h2 id="8、个人操作"><a href="#8、个人操作" class="headerlink" title="8、个人操作"></a>8、个人操作</h2><ol><li>git init    初始化仓库</li><li>git clone 网址    克隆网址上的仓库代码    无法克隆时去控制面板的凭据管理器的Windows凭据中找到其用户名和密码修改</li><li>git config –global –list    查看配置的用户名和邮箱</li><li>git config –global user.name “xx”    设置用户名</li><li>gitconfig –global user.email “xx”    设置用户邮箱</li><li>CD xx    进入克隆下来的文件中</li><li>touch test.txt    新建test.txt文件            rm test.txt    移除一个test.txt文件</li><li>mkdir test    新建一个test文件夹        rm -r test    删除掉test文件夹</li><li>git add test.txt    添加test.txt文件到暂存区</li><li>mv index.html test    把index.html文件移动到test文件夹中（在命令行中的文件）</li><li>reset    重新初始化终端/清屏</li><li>history    查看命令历史</li><li>git commit -m “new test.txt”    多次git add后，提交形成记录，“new test.txt”为提交日志</li><li>git status    查看未提交的文件</li><li>git branch -a    查看所有分支，本地及远程分支</li><li>git checkout -b xxx    以当前分支为基础新建立本地分支xxx</li><li>git checkout -b xxx origin/xxx    以远程分支xxx为基础新建立本地分支xxx，本地分支名和远程分支名一致，不然推送不到远程服务器</li><li>git checkout xxx    切换到本地其他分支，切换前要提交当前分支点改动</li><li>git branch -D xxx    强制删除本地分支</li><li>git push origin –delete xxx    删除远程服务器分支</li><li>git pull origin xxx    从服务器分支更新代码到本地</li><li>git push origin xxx    将数据上推到服务器分支中，上推前先将本地代码更新到最新版本</li><li>git tag xx    建立本地标签</li><li>git tag     查看本地所有标签</li><li>git push origin –tags    把本地的所有文档推送到远程服务器</li><li>git fetch    从远程服务器更新代码到本地，但不自动合并，执行后可以更新分支和tag</li><li>git merge xxx    把本地分支xxx合并到当前分支</li><li>echo “xxxxx” &gt;test.txt    在test.txt文件中写入数据xxxx</li><li>修改git branch -a中显示出了的head指向-git remote set-head origin feature可将head指向feature</li></ol><h4 id="列出本地所有分支："><a href="#列出本地所有分支：" class="headerlink" title="列出本地所有分支："></a>列出本地所有分支：</h4><p>命令：git branch</p><h4 id="创建一个新分支："><a href="#创建一个新分支：" class="headerlink" title="创建一个新分支："></a>创建一个新分支：</h4><p>命令：git branch 分支名称</p><h4 id="删除指定本地分支："><a href="#删除指定本地分支：" class="headerlink" title="删除指定本地分支："></a>删除指定本地分支：</h4><p>命令：git branch -d 删除的分支名称    -D为强制删除，-d为正常操作情况下的删除。</p><h2 id="命令大全"><a href="#命令大全" class="headerlink" title="命令大全"></a>命令大全</h2><p>ls -a    查看目录中的文件夹（蓝色）和文件（白色）</p><p>git add &lt;文件名&gt;    将文件提交到暂存区</p><p>git branch -a    查看本地及远程分支</p><p>git branch -l    查看本地分支</p><p>git branch -r    查看远程所有分支</p><p>git checkout -b dev    建立一个新的本地分支dev</p><p>git checkout dev    切换到本地dev</p><p>git checkout -d master dev    删除本地库dev</p><p>git checkout –track origin/dev    切换到远程dev分支</p><p>git clone 网址    克隆网址上的仓库代码    无法克隆时去控制面板的凭据管理器的Windows凭据中找到其用户名和密码修改</p><p>git commit -m “提交信息”    将暂存区的文件提交到本地仓库</p><p>git diff branchname filepath    当前分支的文件与branchname分支的文件进行比较</p><p>git diff commitld filepath    与某次提交进行比较</p><p>git diff filepath    工作区与暂存区比较</p><p>git diff HEAD filepath 工作区与HEAD（当前工作分支）比较</p><p>git fetch    从远程获取最新版本到本地不会自动merge</p><p>git log    查看git commit的日志，推出git log按下q即可</p><p>git ls-files    显示出暂存区和工作区内的文件</p><p>git merge origin/dev    将分支dev和当前分支合并g’i’tte’ch</p><p>git pull    本地与服务器端同步</p><p>git push origin master    将本地分支推送到服务器master分支上</p><p>gti rm –cache 文件名    仅仅删除暂存区里的文件</p><p>git rm -f 文件名    删除暂存区和工作区的文件</p><p>git reset –soft 版本库ID    撤销已提交的版本库，不会修改暂存区和工作区</p><p>git reset –mixed 版本库ID    撤销已提交的版本库和暂存区不会修改工作区</p><p>git reset hard 版本库ID    彻底将工作区、暂存区和版本库记录恢复到指定的版本库</p><p>git status    查看当前状态</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="学习篇" scheme="https://tqoqt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
    
    <category term="Git" scheme="https://tqoqt.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>四线模拟IIC点亮屏幕</title>
    <link href="https://tqoqt.github.io/posts/stm32001.html"/>
    <id>https://tqoqt.github.io/posts/stm32001.html</id>
    <published>2021-09-01T16:00:00.000Z</published>
    <updated>2021-09-10T16:07:33.829Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>主要是运用stm32F103RBT6 中的模拟IIC点亮四线的OLED屏</p><ul><li><h3 id="先不写上链接"><a href="#先不写上链接" class="headerlink" title="先不写上链接"></a>先不写上链接</h3></li></ul><p>链接：<a href="https://pan.baidu.com/s/1ebrh6OHc7GkQpjKQb7PRlg">https://pan.baidu.com/s/1ebrh6OHc7GkQpjKQb7PRlg</a><br>提取码：1234</p><p>测试一下PicGo图床</p><p><img src="https://i.loli.net/2021/09/02/qrnOW3IYDPUZ7iQ.png" alt="image-20210902234022748"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="学习篇" scheme="https://tqoqt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
    
    <category term="STM32" scheme="https://tqoqt.github.io/tags/STM32/"/>
    
    <category term="STM32CubeMX" scheme="https://tqoqt.github.io/tags/STM32CubeMX/"/>
    
  </entry>
  
  <entry>
    <title>Hexo之渲染绕过</title>
    <link href="https://tqoqt.github.io/posts/17fd92ae.html"/>
    <id>https://tqoqt.github.io/posts/17fd92ae.html</id>
    <published>2020-04-27T16:00:00.000Z</published>
    <updated>2021-06-13T05:55:39.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="0x001-Hexo-渲染"><a href="#0x001-Hexo-渲染" class="headerlink" title="0x001 Hexo 渲染"></a>0x001 Hexo 渲染</h3><p>  在Hexo部署时会默认渲染source下的所有html页面，但有时候想在Hexo博客上单独自定义html页面或README.md时，却不希望被Hexo渲染。因此对某个文件或者目录进行排除渲染是非常必要的。</p><h3 id="0x002-方法一：font-matter"><a href="#0x002-方法一：font-matter" class="headerlink" title="0x002 方法一：font matter"></a>0x002 方法一：font matter</h3><p><code>Hexo</code>新建网站页面，然后将你的代码直接写入 <code>index.md</code> 中</p><p>在 <code>Front matter</code> 中添加 <code>layout: false</code>，此方法适用于单一的纯<code>HTML</code><br><code>CSS</code> 页面。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">---title: toolsdate: <span class="token number">2020</span>-04-28 00:00:00type: <span class="token string">"tools"</span>layout: <span class="token boolean">false</span>---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="0x003-方法二：skip-render"><a href="#0x003-方法二：skip-render" class="headerlink" title="0x003 方法二：skip render"></a>0x003 方法二：skip render</h3><p>在博客根目录下的 <code>_config.yml</code>，找到 <code>skip_render</code>，大概在32行左右，写入你想要的跳过渲染的路径，注意缩进和空格。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 指定目录跳过hexo渲染</span>skip_render:  - <span class="token string">'tools/*'</span>  - <span class="token string">'tools/**'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注释：<code>tools/*</code> 表示在目录 <code>source/fireworks</code> 下的文件全部跳过渲染，<code>tools/**</code> 表示在博客根目录 <code>source/tools/</code> 文件夹下的文件全部跳过渲染（例如页面的 js、css 在另一个文件夹中）。</p></blockquote><h3 id="0x004-案例：webstack-导航"><a href="#0x004-案例：webstack-导航" class="headerlink" title="0x004 案例：webstack 导航"></a>0x004 案例：webstack 导航</h3><p><code>webstack</code>是一个纯静态的网址导航网站，内容均由<code>viggo</code>收集并整理。项目基于<code>bootstrap</code>前端框架开发。</p><p><img src="https://camo.githubusercontent.com/41111c4c1d9922982f380566e6a2f8415204c52c/687474703a2f2f7777772e776562737461636b2e63632f6173736574732f696d616765732f707265766965772e676966" alt="image"></p><ul><li>Github：<a href="https://github.com/WebStackPage/WebStackPage.github.io">https://github.com/WebStackPage/WebStackPage.github.io</a></li></ul><p>在博客根目录 <code>source/</code>下新建<code>tools</code>，然后新建<code>index.html</code>,将<code>webstack</code>网页源码全选复制粘贴到里面。</p><ul><li>本站的webstack源码：<a href="view-source:http://luckyzmj.cn/tools/">view-source:http://luckyzmj.cn/tools/</a></li></ul><blockquote><p>注意：将源码里的部分信息以及跳转链接按照你真实个人博客的环境进行修改。</p></blockquote><p>然后打开博客根目录下配置文件<code>_config.yml</code>，找到<code>skip_render</code>，做如下修改：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">skip_render:  - <span class="token string">'tools/*'</span>  - <span class="token string">'tools/**'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>最后执行<code>hexo clean</code>和<code>hexo s -g </code>本地预览，检查无误后<code>hexo g -d</code>部署到服务器上即可。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://xiabor.com/2020/04/21/hexo3/#%E5%A6%82%E4%BD%95%E8%B7%B3%E8%BF%87hexo%E7%9A%84%E6%B8%B2%E6%9F%93">https://xiabor.com/2020/04/21/hexo3/#%E5%A6%82%E4%BD%95%E8%B7%B3%E8%BF%87hexo%E7%9A%84%E6%B8%B2%E6%9F%93</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="博客篇" scheme="https://tqoqt.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"/>
    
    
    <category term="Hexo" scheme="https://tqoqt.github.io/tags/Hexo/"/>
    
    <category term="渲染绕过" scheme="https://tqoqt.github.io/tags/%E6%B8%B2%E6%9F%93%E7%BB%95%E8%BF%87/"/>
    
  </entry>
  
  <entry>
    <title>PicGo+GitHub 图床搭建</title>
    <link href="https://tqoqt.github.io/posts/7a46f93c.html"/>
    <id>https://tqoqt.github.io/posts/7a46f93c.html</id>
    <published>2020-03-14T16:00:00.000Z</published>
    <updated>2021-06-13T05:55:39.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>用GitHub搭建图床，在很久之前我就有了解，但由于市面上有挺多免费的图床，比如我之前一直在用的 路过图床，所以一直懒得动手搭建GitHub图床。一直到前两天我在完善博客的相册时，发现 路过图床 免费版的有这么多限制，比如：每小时限制上传50张图片，每天限制上传100张图片，而且免费版用户的存储容量貌似不过300M，这才意识到有一个自己的GitHub图床是多么重要。</p><h3 id="0x001-PicGO-介绍"><a href="#0x001-PicGO-介绍" class="headerlink" title="0x001 PicGO 介绍"></a>0x001 PicGO 介绍</h3><p>PicGo是一款图片上传工具，目前支持 SM.MS图床、腾讯云COS、GitHub图床、七牛图床、Imgur图床、阿里云OSS、又拍云图床，未来将支持更多图床。</p><p>在支持的这些图床中，SM.MS和Imgur有免费版和收费版，免费版的肯定有很多的使用限制，比如每小时限制上传次数，限制用户的上传容量等等；腾讯云COS、阿里云、有拍云都是要收费使用的；七牛云貌似前期使用免费，后期又要收费才能使用，就剩下的GitHub才是免费且最可靠的。</p><p>PicGo源项目GitHub地址已给出，但是去GitHub下载速度非常慢，这里额外提供一个蓝奏云的快速下载地址。</p><ul><li>GitHub地址：<a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></li><li>蓝奏云地址：<a href="https://luckyzmj.lanzous.com/id3e0id">https://luckyzmj.lanzous.com/id3e0id</a></li></ul><h3 id="0x002-GitHub-图床"><a href="#0x002-GitHub-图床" class="headerlink" title="0x002 GitHub 图床"></a>0x002 GitHub 图床</h3><h4 id="1-创建GitHub图床仓库"><a href="#1-创建GitHub图床仓库" class="headerlink" title="1. 创建GitHub图床仓库"></a>1. 创建GitHub图床仓库</h4><p>首先需要有一个登录GitHub的账号，没有的话去<a href="https://github.com/">GitHub官网</a>注册一个</p><p>创建一个新的图床仓库，点击右上角的New repository</p><p><img src="https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/posts/20200529155833.png"></p><p>填写如下配置信息，然后Create创建仓库</p><p><img src="https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/posts/20200529160010.png"></p><h4 id="2-获取GitHub-token值"><a href="#2-获取GitHub-token值" class="headerlink" title="2. 获取GitHub token值"></a>2. 获取GitHub token值</h4><p>点击右上的头像，选择设置Setting</p><p><img src="https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/posts/20200529160727.png"></p><p>点击选择Developer settings </p><p><img src="https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/posts/20200529160939.png"></p><p>点击 Generate New token</p><p><img src="https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/posts/20200529161241.png"></p><p>填写如下配置信息，只要勾选repo选项即可，然后页面拉到底部点击Generate token 即可</p><p><img src="https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/posts/20200529161716.png"></p><p>此时会跳转到带有token的页面，将token值复制记录下来，之后用PicGo绑定GitHub图床时会利用到</p><p><img src="https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/posts/20200529162127.png"></p><h3 id="0x003-PicGo-配置"><a href="#0x003-PicGo-配置" class="headerlink" title="0x003 PicGo 配置"></a>0x003 PicGo 配置</h3><h4 id="1-绑定GitHub图床"><a href="#1-绑定GitHub图床" class="headerlink" title="1. 绑定GitHub图床"></a>1. 绑定GitHub图床</h4><p>首先下载安装好PicGo软件，然后在右列表找到GitHub图床配置</p><p><img src="https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/posts/20200529163130.png"></p><p><strong>1. 设定仓库名(必填)：</strong> </p><p>按照“GitHub账户名/仓库名的格式填写”，比如我的是：Luckyzmj/imgbed</p><p><strong>2. 设定分支名(必填)：</strong> </p><p>仓库分支名填写”master”或者”main”，视情况而定。因为GitHub 官方表示,从2020年10月1日起,在该平台上创建的所有新的源代码仓库将默认被命名为”main”,而不是原先的”master”。</p><p><strong>3. 设定Token(必填)：</strong> </p><p>将之前步骤的Token值复制粘贴到这里</p><p><strong>4. 指定存储路径：</strong> </p><p>这个选项可以为空，如果想将图片上传到仓库的指定目录下，可以填写目录名加/，比如我的imgbed仓库下有个posts文件夹，需设置为 posts/</p><p><strong>5. 设定自定义域名：</strong> </p><p>这里统一用jsdelivr的CDN加速域名，在上传图片后成功后，PicGo会将“自定义域名+上传的图片名”生成的访问链接</p><pre class="line-numbers language-none"><code class="language-none">自定义域名格式：https://cdn.jsdelivr.net/gh/GitHub账户名/仓库名以我的格式为例：https://cdn.jsdelivr.net/gh/Luckyzmj/imgbed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>配置完全部信息后，点击 设为默认图床，最后点击确定即可</p><h4 id="2-上传图片到图床"><a href="#2-上传图片到图床" class="headerlink" title="2. 上传图片到图床"></a>2. 上传图片到图床</h4><p>在上传区上传图片，可支持本地图片上传(可多选图片)、剪贴板上传、URL上传等三种方式。上传图片成功后，选择你想要生成的图片链接格式</p><p><img src="https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/posts/20200529170555.png"></p><p>在图片区，可以看到成功上传的图片，选择相应的图片进行操作即可</p><p><img src="https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/posts/20200529170831.png"></p><h4 id="3-PicGo-注意事项"><a href="#3-PicGo-注意事项" class="headerlink" title="3. PicGo 注意事项"></a>3. PicGo 注意事项</h4><p>如果配置完PicGo后却上传图片失败，可以参考以下方法：</p><ol><li>检查自定义域名是否正确</li><li>仓库名不要有空格</li><li>图片名字不要带有特殊符号，如：%、+、*、空格等</li><li>建议开启时间戳重命名，防止图片名字重复</li><li>上传图片间歇太短，需在PicGo设置中关闭Server选项</li><li>PicGo应用不稳定因素，需重启应用</li></ol><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://blog.csdn.net/sunhwee/article/details/100109956">https://blog.csdn.net/sunhwee/article/details/100109956</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="博客篇" scheme="https://tqoqt.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"/>
    
    
    <category term="PicGo" scheme="https://tqoqt.github.io/tags/PicGo/"/>
    
    <category term="GitHub图床" scheme="https://tqoqt.github.io/tags/GitHub%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>阿里云服务器部署Hexo博客</title>
    <link href="https://tqoqt.github.io/posts/19d2a4e6.html"/>
    <id>https://tqoqt.github.io/posts/19d2a4e6.html</id>
    <published>2020-02-26T16:00:00.000Z</published>
    <updated>2021-06-13T05:55:39.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>  相信大部分人使用Hexo搭建个人博客都会部署到一些免费的代码托管平台上，但这些免费的平台总是差强人意，比如国外的GitHub平台虽然完全免费，但在国内访问加载速度非常慢，又或者是国内的码云平台免费版有许多功能被阉割掉了，比如不能自定义域名，不能每次自动刷新提交的代码，需要到码云平台上手动刷新，如此一来非常繁琐。</p><p>  为了有效解决上诉的一些问题，有条件的话，不妨在自己的云服务器上搭建Hexo博客。</p><h2 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h2><hr><p>这是Hexo博客部署到GitHub上的网站测速效果</p><p><img src="https://s1.ax1x.com/2020/03/12/8mhkv9.png" alt="演示demo1"></p><p>这是Hexo博客部署到阿里云服务器后的网站测速效果</p><p><img src="https://s1.ax1x.com/2020/03/12/8mWYQA.png" alt="演示demo2"></p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><hr><ul><li>本地环境：Windows 10 </li><li>云服务器环境：阿里云ECS（CentOS7.x）</li></ul><h2 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h2><hr><h3 id="本地环境搭建"><a href="#本地环境搭建" class="headerlink" title="本地环境搭建"></a>本地环境搭建</h3><p><strong>1.安装Git</strong></p><p>到git官网上下载.exe文件,Download git,安装选项还是全部默认，最后一步添加路径时选择<code>Use Git from the Windows Command Prompt</code>。</p><ul><li>Git<a href="https://git-scm.com/download">下载地址</a></li><li>Git<a href="https://www.liaoxuefeng.com/wiki/896043488029600">教程</a></li></ul><p><strong>2.安装Nodejs</strong></p><p>到<a href="http://nodejs.cn/download/">Node.js官网</a>下载<code>.exe</code>文件，安装选项全部默认。安装好之后，按<code>Win+R</code>打开cmd命令提示符，输入<code>node -v</code>和<code>npm -v</code>，若出现版本号，则说明安装成功。</p><p>使用npm阿里的国内镜像进行加速下载</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> config <span class="token builtin class-name">set</span> registry https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>4.安装Hexo</strong></p><p>先创建一个文件夹<code>MyBlog</code>，用来存放自己的博客文件，然后<code>cd</code>到这个文件夹下（或者在这个文件夹下直接右键<code>git bash here</code>打开）。</p><p>定位到该目录下，输入<code>npm install -g hexo-cli</code>安装<code>Hexo</code>。可能会有几个报错，不用理会。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完后输入<code>hexo -v</code>,若出现版本号则，说明安装成功。</p><p>接下来初始化一下<code>hexo</code>,即初始化我们的博客，输入<code>hexo init</code>初始化文件夹</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo init MyBlog<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新建完成后，指定文件夹<code>MyBlog</code>目录下有：</p><ul><li><code>node_modules</code>: 依赖包</li><li><code>public</code>：存放生成的页面</li><li><code>scaffolds</code>：生成文章的一些模板</li><li><code>source</code>：用来存放你的文章</li><li><code>themes</code>：主题**</li><li><code>_config.yml</code>: 博客的配置文件**</li></ul><p>输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器预览</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo ghexo s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2020/03/12/8VdlGD.png" alt="Hexo"></p><h3 id="生成ssh公钥"><a href="#生成ssh公钥" class="headerlink" title="生成ssh公钥"></a>生成ssh公钥</h3><p>在本地桌面点击右键<code>Git Bash Here</code>打开Git终端，执行如下命令`,一路回车</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen -t rsa<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个时候它会告诉你已经生成了<code>.ssh</code>的文件夹。在<code>git bash</code>中输入</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> ~/.ssh/id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出的内容就是公钥信息了</p><h3 id="阿里云服务器环境搭建"><a href="#阿里云服务器环境搭建" class="headerlink" title="阿里云服务器环境搭建"></a>阿里云服务器环境搭建</h3><p>安装<code>Git</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> <span class="token function">git</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建<code>Git</code>账户</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">adduser <span class="token function">git</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加账户权限</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> <span class="token number">740</span> /etc/sudoers<span class="token function">vim</span> /etc/sudoers<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>找到</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">## Allow root to run any commands anywhere</span>root    <span class="token assign-left variable">ALL</span><span class="token operator">=</span><span class="token punctuation">(</span>ALL<span class="token punctuation">)</span>     ALL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>添加以下内容</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span>   <span class="token assign-left variable">ALL</span><span class="token operator">=</span><span class="token punctuation">(</span>ALL<span class="token punctuation">)</span>     ALL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>保存退出并改回权限</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> <span class="token number">400</span> /etc/sudoers<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置<code>git</code>账户密码</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">passwd</span> <span class="token function">git</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>切换至<code>git</code>用户，创建 <code>~/.ssh</code> 文件夹和 <code>~/.ssh/authorized_keys</code> 文件，并赋予相应的权限</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">su</span> <span class="token function">git</span><span class="token function">mkdir</span> ~/.ssh<span class="token function">vim</span> ~/.ssh/authorized_keys<span class="token comment"># 然后将win10中生成的id_rsa.pub文件中的公钥复制到authorized_keys</span><span class="token function">chmod</span> <span class="token number">600</span> /home/git/.ssh/authorized_keys<span class="token function">chmod</span> <span class="token number">700</span> /home/git/.ssh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在本地<code>Git</code>终端中测试是否能免密登录<code>git</code>，其中<code>SERVER</code>为填写自己的云主机<code>IP</code>，执行输入<code>yes</code>后不用密码就说明好了</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> -v git@SERVER<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#repo作为为Git仓库目录</span><span class="token function">mkdir</span> /var/repo<span class="token function">chown</span> -R git:git /var/repo<span class="token function">chmod</span> -R <span class="token number">755</span> /var/repo<span class="token comment">#hexo作为网站根目录</span><span class="token function">mkdir</span> /var/www/hexo<span class="token function">chown</span> -R git:git /var/www/hexo<span class="token function">chmod</span> -R <span class="token number">755</span> /var/www/hexo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后创建一个裸的 <code>Git</code> 仓库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> var/repo<span class="token function">git</span> init --bare hexoBlog.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>创建一个新的 <code>Git</code> 钩子，用于自动部署 在 <code>/var/repo/hexoBlog.git</code> 下，有一个自动生成的 <code>hooks</code> 文件夹。我们需要在里边新建一个新的钩子文件 <code>post-receive</code>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /var/repo/hexoBlog.git/hooks/post-receive<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按 <code>i</code> 键进入文件的编辑模式，在该文件中添加两行代码（将下边的代码粘贴进去)，指定 <code>Git</code> 的工作树（源代码）和 <code>Git</code> 目录（配置文件等）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token function">git</span> --work-tree<span class="token operator">=</span>/var/www/hexo --git-dir<span class="token operator">=</span>/var/repo/hexoBlog.git checkout -f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后，按 <code>Esc</code> 键退出编辑模式，输入”<code>:wq</code>” 保存退出。</p><p>修改文件权限，使得其可执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chown</span> -R git:git /var/repo/hexoBlog.git/hooks/post-receive<span class="token function">chmod</span> +x /var/repo/hexoBlog.git/hooks/post-receive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>到此为止 <code>Git</code> 仓库就搭建完成了。</p><h3 id="阿里云服务器配置Nginx"><a href="#阿里云服务器配置Nginx" class="headerlink" title="阿里云服务器配置Nginx"></a>阿里云服务器配置Nginx</h3><p>用宝塔面板来一键部署Nginx <code>Linux</code>面板6.0安装命令(暂时仅兼容<code>Centos7.x</code>，其它系统版本请安装5.9稳定版)：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> -y <span class="token function">wget</span> <span class="token operator">&amp;&amp;</span> <span class="token function">wget</span> -O install.sh http://download.bt.cn/install/install_6.0.sh <span class="token operator">&amp;&amp;</span> <span class="token function">bash</span> install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>Linux</code>面板6.0升级专业版</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> http://download.bt.cn/install/update6.sh<span class="token operator">|</span><span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完成后会显示面板后台地址·账号·密码。打开面板后台地址登陆面板，选择<code>Nginx</code>的部署方案，静静等待部署。</p><p>部署完成，点击网站-添加站点-输入域名(没有域名的输入自己的<code>IP</code>地址)-底部的<code>PHP</code>版本选择”纯静态”-提交。 </p><p>网站创建完成后点击设置-配置文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server<span class="token punctuation">{</span>    listen <span class="token number">80</span><span class="token punctuation">;</span>  <span class="token comment"># server_name 填写自己的域名</span>    server_name luckyzmj.cn blog.luckyzmj.cn<span class="token punctuation">;</span>    index index.php index.html index.htm default.php default.htm default.html<span class="token punctuation">;</span>  <span class="token comment"># 这里root填写自己的网站根目录，修改为/var/www/hexo</span>    root /var/www/hexo<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>-保存</p><p>点击设置-网站目录，修改为<code>/var/www/hexo</code> ，保存</p><p>重启宝塔面板服务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">service</span> bt restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="本地Hexo部署到阿里云服务器"><a href="#本地Hexo部署到阿里云服务器" class="headerlink" title="本地Hexo部署到阿里云服务器"></a>本地Hexo部署到阿里云服务器</h3><p>进入到本地<code>Hexo</code>博客的文件夹<code>MyBlog</code>,右键点击<code>Git Bash Here</code>，输入命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#定义邮箱(更换为你的邮箱地址就行)</span><span class="token function">git</span> config --global user.email <span class="token string">"you@example.com"</span><span class="token comment">#定义名称(更换自定义一个名称就行)</span><span class="token function">git</span> config --global user.name <span class="token string">"Your Name"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>配置<code>_config.yml</code>,完成自动化部署 </p><p>打开本地<code>Hexo</code>博客的文件夹<code>MyBlog</code>文件夹下的<code>_config.yml</code>, 找到<code>deploy</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">deploy:  type: <span class="token function">git</span>  <span class="token comment">#server改为你的服务IP地址或解析后的域名</span>  <span class="token comment">#例如我改为repo: git@luckyzmj.cn:/var/repo/blog.git</span>  repo: git@server:/var/repo/blog.git  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>保存后，即可测试部署</p><p>再进入到本地<code>Hexo</code>博客的文件夹<code>MyBlog</code>,右键点击<code>Git Bash Here</code>，输入命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo clean hexo g -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>不报错说明完成，打开浏览器输入你的域名或<code>ip</code>地址就可以看到你部署的<code>Hexo</code>博客了。 </p><p>到此为止，我们已经成功部完成，并且访问自己的服务器端比访问Github快多了。</p><blockquote><h3 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h3></blockquote><p>在部署过程中，执行 hexo d发现部署老是出错，什么权限不允许之类的，这里我们需要检查我们在上述的<code>git</code>操作部署是否使用了<code>git</code>用户操作，若是没有，需要给相应的目录更改用户组 使用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chown</span> -R git:git /var/repo/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条命令递归的将<code>repo</code>目录及其子目录用户组设置为<code>git</code>。 同时使用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chown</span> -R git:git /var/www/hexo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样即可解决此类问题。</p><p>还有一个问题就是绑定域名后不能访问。原因是在国内任何域名只要绑定到国内的服务器主机上都必须去工信部和公安部备案完后才能正常使用。如果是港澳台的服务器或者是国外的服务器则可以不需要备案。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.csdn.net/weixin_33907511/article/details/91398208?utm_source=distribute.pc_relevant.none-task">https://blog.csdn.net/weixin_33907511/article/details/91398208?utm_source=distribute.pc_relevant.none-task</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="博客篇" scheme="https://tqoqt.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"/>
    
    
    <category term="Hexo" scheme="https://tqoqt.github.io/tags/Hexo/"/>
    
    <category term="阿里云" scheme="https://tqoqt.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
    <category term="博客" scheme="https://tqoqt.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
